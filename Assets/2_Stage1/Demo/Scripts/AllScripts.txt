===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/BlockHitDetector.cs =====
using UnityEngine;

public class BlockHitDetector : MonoBehaviour
{
    public RhythmConductor conductor;
    public DebugHUD hud;

    void OnCollisionEnter(Collision collision)
    {
        if (!conductor) return;
        if (conductor.IsJudgingWindow()) return; // judging이면 block collider가 꺼져있는 구성이 일반적

        // WrongCut feedback (debug only)
        if (hud) hud.Log("WrongCut: Hit blocked Kimbap (Non-Judging)");
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/DebugHUD.cs =====
using System.Diagnostics;
using UnityEngine;

public class DebugHUD : MonoBehaviour
{
    RhythmConductor _conductor;
    string _logLine = "";
    float _logTimer;

    public KnifeVelocityEstimator knifeSpeedSource;

    public void Bind(RhythmConductor c) => _conductor = c;

    public void Log(string msg)
    {
        _logLine = msg;
        _logTimer = 2.5f;
        UnityEngine.Debug.Log("[HUD] " + msg);
    }

    void Update()
    {
        if (_logTimer > 0f) _logTimer -= Time.deltaTime;
    }

    void OnGUI()
    {
        if (_conductor == null) return;

        GUIStyle s = new GUIStyle(GUI.skin.label)
        {
            fontSize = 16
        };

        float x = 12, y = 12, w = 640, h = 22;

        GUI.Label(new Rect(x, y, w, h), $"State: {_conductor.State}", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"BGM Time: {_conductor.BgmTime:F3}s", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"Trigger Index: {_conductor.CurrentTriggerIndex}", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"SliceCount: {_conductor.SliceCount} / {_conductor.RequiredSliceCount}", s); y += h;

        float spd = knifeSpeedSource ? knifeSpeedSource.speed : 0f;
        GUI.Label(new Rect(x, y, w, h), $"Knife Speed: {spd:F2}", s); y += h;

        if (_logTimer > 0f)
        {
            GUI.Label(new Rect(x, y + 8, w, h), $"LOG: {_logLine}", s);
        }
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KimbapController.cs =====
using System.Diagnostics;
using UnityEngine;

#if EZYSlice
using EzySlice;
#endif

public class KimbapController : MonoBehaviour
{
    public enum AxisMode
    {
        WorldX,             // 월드 +X (사진 기준 동쪽을 이걸로 쓰는 경우가 많음)
        WorldZ,             // 월드 +Z
        ReferenceRight,     // axisReference.right
        ReferenceForward    // axisReference.forward
    }

    [Header("Thin Piece Timing")]
    public float thinFlySeconds = 0.22f;
    public float thinLifeSeconds = 1.2f;

    [Header("Refs")]
    public Collider sliceTrigger;     // Trigger collider (KimbapSliceable layer)
    public Collider blockCollider;    // Solid collider (KimbapBlocked layer)
    public Transform mainMeshRoot;    // Mesh-only object (없으면 런타임에 자동 생성/분리)
    public Material crossSectionMaterial;

    [Header("Slice Direction")]
    public AxisMode axisMode = AxisMode.WorldX;
    public Transform axisReference;   // 테이블 같은 기준 Transform (Reference 모드에서 사용)
    public bool invertAxis = false;

    [Header("Debug")]
    public bool debugDrawPlane = true;
    public float debugDrawSeconds = 0.25f;

    [Header("Runtime")]
    public bool sliceable;

    RhythmTriggerListSO.Trigger _trigger;

    // current mesh GO (항상 "메쉬 전용" 오브젝트를 가리키게 유지)
    GameObject _currentMeshGO;

    int _activeThinPieces;

    void Awake()
    {
        // 기본은 막힘
        SetSliceable(false);

        // 루트에 Mesh가 붙어있으면 런타임에 메쉬 전용 자식으로 분리
        EnsureMeshRoot();

        _currentMeshGO = FindMeshGameObject(mainMeshRoot);
        if (_currentMeshGO == null)
            UnityEngine.Debug.LogWarning("[KimbapController] MeshFilter not found under mainMeshRoot.");
    }

    public void BeginTrigger(RhythmTriggerListSO.Trigger trigger)
    {
        _trigger = trigger;
        _activeThinPieces = 0;

        EnsureMeshRoot();
        _currentMeshGO = FindMeshGameObject(mainMeshRoot);
        SetSliceable(false);
    }

    public void SetSliceable(bool value)
    {
        sliceable = value;
        if (sliceTrigger) sliceTrigger.enabled = value;
        if (blockCollider) blockCollider.enabled = !value;
    }

    public void OnTriggerResult(bool success)
    {
        UnityEngine.Debug.Log($"[KimbapController] Trigger result: {(success ? "SUCCESS" : "FAIL")}");
    }

    public bool CanSpawnThinPiece()
    {
        if (_trigger == null) return true;
        return _activeThinPieces < Mathf.Max(1, _trigger.maxActiveThinPieces);
    }

    public void NotifyThinPieceSpawned() => _activeThinPieces++;
    public void NotifyThinPieceDespawned() => _activeThinPieces = Mathf.Max(0, _activeThinPieces - 1);

    Vector3 GetCutAxis()
    {
        Vector3 axis = Vector3.right;

        switch (axisMode)
        {
            case AxisMode.WorldX: axis = Vector3.right; break;
            case AxisMode.WorldZ: axis = Vector3.forward; break;
            case AxisMode.ReferenceRight:
                axis = axisReference ? axisReference.right : Vector3.right;
                break;
            case AxisMode.ReferenceForward:
                axis = axisReference ? axisReference.forward : Vector3.forward;
                break;
        }

        axis = axis.normalized;
        if (invertAxis) axis = -axis;
        return axis;
    }

    /// <summary>
    /// 사진 기준 "동쪽(=Axis)"에서 얇게 한 장씩 떼어내는 절단.
    /// sliceIndex0Based는 thin thickness curve용.
    /// </summary>
    public bool ExecuteRightThinSlice(int sliceIndex0Based)
    {
#if !EZYSlice
        UnityEngine.Debug.LogWarning("[KimbapController] EZYSlice not enabled. Add EzySlice and define scripting symbol EZYSlice.");
        return false;
#else
        if (_trigger == null)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] No trigger bound.");
            return false;
        }

        EnsureMeshRoot();

        if (_currentMeshGO == null)
        {
            _currentMeshGO = FindMeshGameObject(mainMeshRoot);
            if (_currentMeshGO == null)
            {
                UnityEngine.Debug.LogWarning("[KimbapController] Mesh object not found.");
                return false;
            }
        }

        var rend = _currentMeshGO.GetComponentInChildren<Renderer>();
        if (!rend)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] Renderer not found on mesh.");
            return false;
        }

        // 절단 축(사진 기준 동쪽)
        Vector3 axis = GetCutAxis();

        // thickness 계산
        float tNorm = _trigger.thinSliceThicknessNorm;
        if (_trigger.thinThicknessCurve != null && _trigger.thinThicknessCurve.length > 0 && _trigger.requiredSliceCount > 1)
        {
            float u = sliceIndex0Based / (float)(_trigger.requiredSliceCount - 1);
            float cu = _trigger.thinThicknessCurve.Evaluate(u);
            if (cu > 0f) tNorm = cu;
        }

        Bounds wb = rend.bounds;

        // bounds corners를 axis에 투영해서 길이 측정
        GetMinMaxAlongDir(wb, axis, out float minD, out float maxD);
        float lengthAlongAxis = Mathf.Max(0.0001f, maxD - minD);

        float thinWorld = Mathf.Max(lengthAlongAxis * tNorm, _trigger.minThinThicknessWorld);

        // "동쪽 끝" (axis 방향의 max 쪽)
        // AABB는 axis 방향으로 center 기준 대칭이므로 아래 방식이 안정적
        Vector3 axisEnd = wb.center + axis * (lengthAlongAxis * 0.5f);

        // axisEnd에서 thinWorld만큼 안쪽으로 들어온 지점에 절단 평면 생성
        Vector3 planePoint = axisEnd - axis * thinWorld;
        Vector3 planeNormal = axis; // normal이 axis 쪽을 향하면 axisEnd 쪽 조각이 얇게 떨어짐

        if (debugDrawPlane)
        {
           UnityEngine.Debug.DrawRay(planePoint, planeNormal * 0.2f, Color.green, debugDrawSeconds);
            UnityEngine.Debug.DrawRay(planePoint, -planeNormal * 0.2f, Color.red, debugDrawSeconds);
        }

        // 슬라이스는 "메쉬 전용 오브젝트"만 대상으로!
        // (루트는 절대 Destroy 하면 안 됨)
        Transform meshT = _currentMeshGO.transform;

        // 루트 기준 로컬 포즈 저장(슬라이스 후에도 동일 포즈 유지)
        Transform root = transform;
        Vector3 localPos = root.InverseTransformPoint(meshT.position);
        Quaternion localRot = Quaternion.Inverse(root.rotation) * meshT.rotation;
        Vector3 localScale = meshT.localScale;

        // 실제 슬라이스
        var hull = _currentMeshGO.Slice(planePoint, planeNormal, crossSectionMaterial);
        if (hull == null)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] Slice returned null (failed). Try enabling Read/Write on mesh import, or adjust axis.");
            return false;
        }

        GameObject upper = hull.CreateUpperHull(_currentMeshGO, crossSectionMaterial);
        GameObject lower = hull.CreateLowerHull(_currentMeshGO, crossSectionMaterial);

        if (!upper || !lower)
        {
            if (upper) Destroy(upper);
            if (lower) Destroy(lower);
            UnityEngine.Debug.LogWarning("[KimbapController] Hull create failed.");
            return false;
        }

        // big/small 선택(더 큰 쪽이 본체)
        float vu = BoundsVolume(upper);
        float vl = BoundsVolume(lower);
        GameObject big = (vu >= vl) ? upper : lower;
        GameObject small = (big == upper) ? lower : upper;

        // 기존 메쉬 오브젝트 제거
        Destroy(_currentMeshGO);

        // big/small을 루트 아래로 붙이고 로컬 포즈 복원
        big.name = "MainMeshRuntime";
        big.transform.SetParent(root, false);
        big.transform.localPosition = localPos;
        big.transform.localRotation = localRot;
        big.transform.localScale = localScale;

        small.transform.SetParent(root, false);
        small.transform.localPosition = localPos;
        small.transform.localRotation = localRot;
        small.transform.localScale = localScale;

        // 현재 메쉬 갱신
        mainMeshRoot = big.transform;
        _currentMeshGO = big;

        // 얇은 조각 연출
        if (CanSpawnThinPiece())
        {
            NotifyThinPieceSpawned();

            var tp = small.AddComponent<ThinPieceAutoCleanup>();
            tp.owner = this;
            tp.flyDirection = axis;     // 동쪽으로 살짝 튕기기
            tp.flySeconds = 0.22f;
            tp.lifeSeconds = 1.2f;

            foreach (var c in small.GetComponentsInChildren<Collider>())
                c.enabled = false;
        }
        else
        {
            Destroy(small);
        }

        return true;
#endif
    }

    // --- 핵심: 루트에 Mesh가 붙어있으면 메쉬만 자식으로 분리해서 "루트 파괴" 방지 ---
    void EnsureMeshRoot()
    {
        if (mainMeshRoot && FindMeshGameObject(mainMeshRoot)) return;

        // 루트에 Mesh가 붙어 있으면 런타임 복제해서 자식으로 분리
        var mf = GetComponent<MeshFilter>();
        var mr = GetComponent<MeshRenderer>();
        if (mf && mr)
        {
            var go = new GameObject("MainMeshRuntime");
            go.transform.SetParent(transform, false);
            go.transform.localPosition = Vector3.zero;
            go.transform.localRotation = Quaternion.identity;
            go.transform.localScale = Vector3.one;

            var newMf = go.AddComponent<MeshFilter>();
            newMf.sharedMesh = mf.sharedMesh;

            var newMr = go.AddComponent<MeshRenderer>();
            newMr.sharedMaterials = mr.sharedMaterials;

            // 루트 MeshRenderer는 꺼두기(콜라이더/스크립트는 유지)
            mr.enabled = false;
            mf.mesh = null;

            mainMeshRoot = go.transform;
            _currentMeshGO = go;
            return;
        }

        // 루트에 Mesh가 없다면(이미 자식 구조일 수도)
        // mainMeshRoot를 루트로 두고 검색
        if (!mainMeshRoot) mainMeshRoot = transform;
    }

    static GameObject FindMeshGameObject(Transform root)
    {
        if (!root) return null;
        var mfSelf = root.GetComponent<MeshFilter>();
        if (mfSelf) return mfSelf.gameObject;
        var mf = root.GetComponentInChildren<MeshFilter>();
        return mf ? mf.gameObject : null;
    }

    static float BoundsVolume(GameObject go)
    {
        var r = go.GetComponentInChildren<Renderer>();
        if (!r) return 0f;
        var b = r.bounds;
        return b.size.x * b.size.y * b.size.z;
    }

    static void GetMinMaxAlongDir(Bounds b, Vector3 dir, out float min, out float max)
    {
        dir.Normalize();
        Vector3 c = b.center;
        Vector3 e = b.extents;

        Vector3[] corners = new Vector3[8]
        {
            c + new Vector3( e.x,  e.y,  e.z),
            c + new Vector3( e.x,  e.y, -e.z),
            c + new Vector3( e.x, -e.y,  e.z),
            c + new Vector3( e.x, -e.y, -e.z),
            c + new Vector3(-e.x,  e.y,  e.z),
            c + new Vector3(-e.x,  e.y, -e.z),
            c + new Vector3(-e.x, -e.y,  e.z),
            c + new Vector3(-e.x, -e.y, -e.z),
        };

        min = float.PositiveInfinity;
        max = float.NegativeInfinity;

        for (int i = 0; i < corners.Length; i++)
        {
            float d = Vector3.Dot(corners[i], dir);
            if (d < min) min = d;
            if (d > max) max = d;
        }
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KimbapSliceTarget.cs =====
using UnityEngine;

public class KimbapSliceTarget : MonoBehaviour
{
    public KimbapController controller;

    void Awake()
    {
        if (!controller) controller = GetComponentInParent<KimbapController>();
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KimbapSpawner.cs =====
using System.Diagnostics;
using UnityEngine;

public class KimbapSpawner : MonoBehaviour
{
    public KimbapController kimbapPrefab;
    public Transform spawnPoint;

    public KimbapController CurrentKimbap { get; private set; }

    public void EnsureKimbapExists()
    {
        if (CurrentKimbap) return;
        SpawnNew();
    }

    public void SpawnNew()
    {
        if (!kimbapPrefab)
        {
            UnityEngine.Debug.LogError("[KimbapSpawner] Missing kimbapPrefab.");
            return;
        }

        Vector3 pos = spawnPoint ? spawnPoint.position : transform.position;
        Quaternion rot = spawnPoint ? spawnPoint.rotation : transform.rotation;

        CurrentKimbap = Instantiate(kimbapPrefab, pos, rot);
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KnifePhysicsFollowerOVR.cs =====
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class KnifePhysicsFollowerOVR : MonoBehaviour
{
    public Transform target;
    public Rigidbody rb;

    [Range(0.01f, 1f)] public float positionLerp = 0.5f;
    [Range(0.01f, 1f)] public float rotationLerp = 0.35f;
    public float maxMoveSpeed = 12f;
    public float maxTurnSpeed = 480f;

    Vector3 _targetPos;
    Quaternion _targetRot;
    bool _hasTargetPose;

    void Awake()
    {
        if (!rb) rb = GetComponent<Rigidbody>();
    }

    void Update()
    {
        if (!target) return;
        _targetPos = target.position;
        _targetRot = target.rotation;
        _hasTargetPose = true;
    }

    void FixedUpdate()
    {
        if (!rb || !_hasTargetPose) return;

        // --- Position ---
        Vector3 delta = _targetPos - rb.position;
        float maxStep = maxMoveSpeed * Time.fixedDeltaTime;
        Vector3 step = Vector3.ClampMagnitude(delta, maxStep);
        Vector3 nextPos = rb.position + step;
        nextPos = Vector3.Lerp(rb.position, nextPos, positionLerp);
        rb.MovePosition(nextPos);

        // --- Rotation ---
        Quaternion desiredRot = _targetRot;

        Quaternion dq = desiredRot * Quaternion.Inverse(rb.rotation);
        dq.ToAngleAxis(out float angle, out Vector3 axis);
        if (angle > 180f) angle -= 360f;

        float maxAngleStep = maxTurnSpeed * Time.fixedDeltaTime;
        float clamped = Mathf.Clamp(angle, -maxAngleStep, maxAngleStep);
        Quaternion stepRot = Quaternion.AngleAxis(clamped, axis);

        Quaternion nextRot = stepRot * rb.rotation;
        nextRot = Quaternion.Slerp(rb.rotation, nextRot, rotationLerp);
        rb.MoveRotation(nextRot);
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KnifeSlicer.cs =====
using UnityEngine;

public class KnifeSlicer : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public KnifeVelocityEstimator velocityEstimator;
    public KnifeVisualResistance visualResistance;

    [Header("Hand")]
    public bool rightHand = true;

    [Header("Audio")]
    public AudioSource sfxSource;

    // attempt lock
    bool _canSlice = true;
    float _contactMs;

    KimbapController _currentKimbap;
    int _sliceIndexThisTrigger;

    void Awake()
    {
        if (!sfxSource) sfxSource = gameObject.AddComponent<AudioSource>();
    }

    void Update()
    {
        // Reset per-trigger index when trigger changes
        if (!conductor) return;

        // If not judging, allow slice again but don't keep old target
        if (!conductor.IsJudgingWindow())
        {
            _canSlice = true;
            _contactMs = 0f;
            _currentKimbap = null;
            _sliceIndexThisTrigger = 0;
            return;
        }
    }

    void OnTriggerEnter(Collider other)
    {
        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target || !target.controller) return;

        _currentKimbap = target.controller;
        _contactMs = 0f;
    }

    void OnTriggerStay(Collider other)
    {
        if (!conductor || !conductor.IsJudgingWindow()) return;
        if (!_canSlice) return;

        var trigger = conductor.GetCurrentTrigger();
        if (trigger == null) return;

        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target || !target.controller) return;

        // Must be sliceable state
        if (!target.controller.sliceable) return;

        // Contact time
        _contactMs += Time.deltaTime * 1000f;
        if (_contactMs < trigger.minContactMs) return;

        // Speed check
        float speed = velocityEstimator ? velocityEstimator.speed : 0f;
        if (speed < trigger.minKnifeSpeed)
        {
            // Optional: very soft negative feedback (no penalty)
            return;
        }

        // VALID SLICE!
        _canSlice = false;

        // 1) register count
        conductor.RegisterValidSlice();

        // 2) feedback
        float amp = Mathf.Lerp(trigger.hapticHitBase, trigger.hapticHitMax, Mathf.Clamp01(speed / (trigger.minKnifeSpeed * 2f)));
        XRHaptics.SendHaptic(rightHand, amp, trigger.hapticDurationMs / 1000f);
        // second tap
        XRHaptics.SendHaptic(rightHand, amp * 0.85f, Mathf.Max(0.01f, trigger.hapticDurationMs / 1600f));

        if (trigger.impactSound) sfxSource.PlayOneShot(trigger.impactSound);

        if (visualResistance)
            visualResistance.Play(trigger.visualResistanceMs, trigger.visualResistanceStrength);

        if (trigger.cutVfxPrefab)
        {
            // spawn at contact approx (knife trigger position)
            var vfx = GameObject.Instantiate(trigger.cutVfxPrefab, transform.position, Quaternion.identity);
            GameObject.Destroy(vfx, 1.5f);
        }

        // 3) RightThin slice (EzySlice)
        if (_currentKimbap)
        {
            int idx0 = _sliceIndexThisTrigger;
            _sliceIndexThisTrigger++;
            _currentKimbap.ExecuteRightThinSlice(idx0);
        }

        // Unlock after short cooldown (prevents multi-count in same swing)
        Invoke(nameof(UnlockSlice), 0.12f);
    }

    void OnTriggerExit(Collider other)
    {
        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target) return;

        _contactMs = 0f;

        // exit allows next slice sooner
        if (conductor && conductor.IsJudgingWindow())
            _canSlice = true;
    }

    void UnlockSlice()
    {
        _contactMs = 0f;
        _canSlice = true;
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KnifeVelocityEstimator.cs =====
using UnityEngine;

public class KnifeVelocityEstimator : MonoBehaviour
{
    public Transform samplePoint; // blade tip or knife root
    public float speed { get; private set; }

    Vector3 _prevPos;
    bool _hasPrev;

    void Start()
    {
        if (!samplePoint) samplePoint = transform;
    }

    void Update()
    {
        Vector3 p = samplePoint.position;
        if (_hasPrev)
        {
            float dt = Mathf.Max(Time.deltaTime, 0.0001f);
            speed = Vector3.Distance(p, _prevPos) / dt;
        }
        _prevPos = p;
        _hasPrev = true;
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/KnifeVisualResistance.cs =====
using UnityEngine;

public class KnifeVisualResistance : MonoBehaviour
{
    public Transform knifeVisual; // assign model root
    public Vector3 localBackAxis = Vector3.back; // visual moves slightly backward on hit
    public float maxOffset = 0.015f;

    float _timer;
    float _dur;
    float _strength;
    Vector3 _baseLocalPos;

    void Awake()
    {
        if (!knifeVisual) knifeVisual = transform;
        _baseLocalPos = knifeVisual.localPosition;
    }

    public void Play(int milliseconds, float strength01)
    {
        _dur = Mathf.Clamp(milliseconds / 1000f, 0.03f, 0.25f);
        _timer = _dur;
        _strength = Mathf.Clamp01(strength01);
    }

    void LateUpdate()
    {
        if (_timer <= 0f)
        {
            knifeVisual.localPosition = Vector3.Lerp(knifeVisual.localPosition, _baseLocalPos, 0.35f);
            return;
        }

        _timer -= Time.deltaTime;
        float u = 1f - Mathf.Clamp01(_timer / _dur); // 0->1
        // ease in/out
        float k = Mathf.Sin(u * Mathf.PI);
        Vector3 offset = localBackAxis.normalized * (maxOffset * _strength * k);
        knifeVisual.localPosition = _baseLocalPos + offset;
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/RhythmConductor.cs =====
using System.Diagnostics;
using UnityEngine;

public class RhythmConductor : MonoBehaviour
{
    public enum RhythmState { Waiting, Guiding, Judging, Result }

    [Header("Data")]
    public RhythmTriggerListSO data;

    [Header("Refs")]
    public AudioSource bgmSource;
    public AudioSource sfxSource;
    public KimbapSpawner spawner;
    public DebugHUD hud;

    public RhythmState State { get; private set; } = RhythmState.Waiting;
    public int CurrentTriggerIndex { get; private set; } = -1;

    public float BgmTime { get; private set; } // seconds, with offset applied
    public int SliceCount { get; private set; }
    public int RequiredSliceCount { get; private set; }

    float _offsetSec;
    float _stateEndTime; // in BgmTime domain
    bool _bgmStarted;

    void Awake()
    {
        if (!bgmSource) bgmSource = gameObject.AddComponent<AudioSource>();
        if (!sfxSource) sfxSource = gameObject.AddComponent<AudioSource>();
        _offsetSec = (data ? data.timingOffsetMs : 0f) / 1000f;

        if (hud) hud.Bind(this);
    }

    void Start()
    {
        StartGame();
    }

    public void StartGame()
    {
        if (!data || !data.bgm)
        {
            UnityEngine.Debug.LogError("[RhythmConductor] Missing data/bgm.");
            return;
        }

        bgmSource.clip = data.bgm;
        bgmSource.Play();
        _bgmStarted = true;

        State = RhythmState.Waiting;
        CurrentTriggerIndex = -1;
        SliceCount = 0;
        RequiredSliceCount = 0;

        // Spawn first Kimbap
        if (spawner) spawner.EnsureKimbapExists();
    }

    void Update()
    {
        if (!_bgmStarted) return;

        // Use AudioSource.time for simplicity in editor/simulator.
        // (Later you can upgrade to DSP time if needed.)
        BgmTime = bgmSource.time + _offsetSec;

        AdvanceTriggerIfNeeded();
        TickStateMachine();
    }

    void AdvanceTriggerIfNeeded()
    {
        if (data.triggers == null || data.triggers.Length == 0) return;

        int nextIndex = CurrentTriggerIndex + 1;
        if (nextIndex >= data.triggers.Length) return;

        if (BgmTime >= data.triggers[nextIndex].triggerTime)
        {
            EnterTrigger(nextIndex);
        }
    }

    void EnterTrigger(int idx)
    {
        CurrentTriggerIndex = idx;
        var t = data.triggers[idx];

        SliceCount = 0;
        RequiredSliceCount = Mathf.Max(1, t.requiredSliceCount);

        // Prepare Kimbap for judging
        if (spawner && spawner.CurrentKimbap)
        {
            spawner.CurrentKimbap.BeginTrigger(t);
        }

        // Guiding state
        State = RhythmState.Guiding;
        _stateEndTime = BgmTime + Mathf.Max(0.01f, t.guideDuration);

        if (t.guideBeatSound && sfxSource) sfxSource.PlayOneShot(t.guideBeatSound);

        if (hud) hud.Log($"Enter Trigger #{idx} (req={RequiredSliceCount})");
    }

    void TickStateMachine()
    {
        if (CurrentTriggerIndex < 0) return;
        var t = data.triggers[CurrentTriggerIndex];

        if (State == RhythmState.Guiding && BgmTime >= _stateEndTime)
        {
            State = RhythmState.Judging;
            _stateEndTime = BgmTime + Mathf.Max(0.01f, t.judgeDuration);

            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.SetSliceable(true);

            if (hud) hud.Log("State -> Judging");
        }
        else if (State == RhythmState.Judging && BgmTime >= _stateEndTime)
        {
            State = RhythmState.Result;

            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.SetSliceable(false);

            bool success = (SliceCount == RequiredSliceCount);
            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.OnTriggerResult(success);

            if (hud) hud.Log($"State -> Result (success={success})");

            // Immediately go back to Waiting for next trigger (keeps flow)
            State = RhythmState.Waiting;
        }
    }

    public bool IsJudgingWindow()
    {
        return State == RhythmState.Judging && CurrentTriggerIndex >= 0;
    }

    public RhythmTriggerListSO.Trigger GetCurrentTrigger()
    {
        if (!data || data.triggers == null) return null;
        if (CurrentTriggerIndex < 0 || CurrentTriggerIndex >= data.triggers.Length) return null;
        return data.triggers[CurrentTriggerIndex];
    }

    // Called by Knife slicer on valid hit
    public void RegisterValidSlice()
    {
        var t = GetCurrentTrigger();
        if (t == null) return;

        SliceCount++;
        if (hud) hud.Log($"ValidSlice! ({SliceCount}/{RequiredSliceCount})");
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/RhythmTriggerSO.cs =====
using UnityEngine;

[CreateAssetMenu(menuName = "KimbapRhythm/Rhythm Trigger List", fileName = "RhythmTriggerList")]
public class RhythmTriggerListSO : ScriptableObject
{
    public AudioClip bgm;
    public float timingOffsetMs = 0f;

    public Trigger[] triggers;

    [System.Serializable]
    public class Trigger
    {
        [Header("Time")]
        public float triggerTime;      // seconds on BGM timeline
        public float guideDuration = 0.4f;
        public float judgeDuration = 0.6f;
        public AudioClip guideBeatSound;

        [Header("Counts")]
        public int requiredSliceCount = 5;

        [Header("Judgement (simple)")]
        public float minKnifeSpeed = 1.0f; // m/s-ish (depends on scale)
        public float minContactMs = 10f;

        [Header("RightThin Slice (fixed)")]
        public float thinSliceThicknessNorm = 0.08f;
        public AnimationCurve thinThicknessCurve; // optional
        public float minThinThicknessWorld = 0.01f;
        public int maxActiveThinPieces = 6;

        [Header("Feedback")]
        [Range(0f, 1f)] public float hapticHitBase = 0.25f;
        [Range(0f, 1f)] public float hapticHitMax = 0.75f;
        public int hapticDurationMs = 25;
        public AudioClip impactSound;
        public AudioClip swishSound;
        public GameObject cutVfxPrefab;
        [Range(0f, 1f)] public float visualResistanceStrength = 0.6f;
        public int visualResistanceMs = 80;
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/ThinPieceAutoCleanup.cs =====
using UnityEngine;

public class ThinPieceAutoCleanup : MonoBehaviour
{
    public KimbapController owner;
    public Vector3 flyDirection = Vector3.right;

    public float flySeconds = 0.2f;
    public float lifeSeconds = 1.2f;

    Vector3 _startPos;
    Quaternion _startRot;
    float _t;

    void Start()
    {
        _startPos = transform.position;
        _startRot = transform.rotation;

        // Remove heavy physics by default
        var rb = GetComponent<Rigidbody>();
        if (rb) Destroy(rb);

        // You can add a light collider if you want, but prototype ok without.
        // Disable colliders to avoid unexpected physics
        foreach (var c in GetComponentsInChildren<Collider>())
            c.enabled = false;
    }

    void Update()
    {
        _t += Time.deltaTime;

        // Fly animation
        if (_t <= flySeconds && flySeconds > 0f)
        {
            float u = _t / flySeconds;
            float ease = 1f - Mathf.Pow(1f - u, 3f);
            transform.position = _startPos + flyDirection.normalized * (0.06f * ease) + Vector3.up * (0.02f * ease);
            transform.rotation = _startRot * Quaternion.Euler(0f, 0f, 18f * ease);
        }

        if (_t >= lifeSeconds)
        {
            if (owner) owner.NotifyThinPieceDespawned();
            Destroy(gameObject);
        }
    }
}


===== /c/Users/A1/Documents/GitHub/asdf/DDT/Assets/2_Stage1/Demo/Scripts/XRHaptics.cs =====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

public static class XRHaptics
{
    public static void SendHaptic(bool rightHand, float amplitude01, float durationSeconds)
    {
        amplitude01 = Mathf.Clamp01(amplitude01);
        durationSeconds = Mathf.Clamp(durationSeconds, 0.01f, 0.25f);

        var desired = rightHand ? InputDeviceCharacteristics.Right : InputDeviceCharacteristics.Left;
        desired |= InputDeviceCharacteristics.Controller;

        var devices = new List<InputDevice>();
        InputDevices.GetDevicesWithCharacteristics(desired, devices);

        foreach (var d in devices)
        {
            if (!d.isValid) continue;
            if (d.TryGetHapticCapabilities(out var caps) && caps.supportsImpulse)
            {
                // channel 0 is common
                d.SendHapticImpulse(0u, amplitude01, durationSeconds);
                return;
            }
        }
        // Simulator/Editor may not support haptics; that's okay.
    }
}


