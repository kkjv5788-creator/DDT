
/* =====================================================================
   FILE: BlockHitDetector.cs
   ===================================================================== */

using UnityEngine;

public class BlockHitDetector : MonoBehaviour
{
    public RhythmConductor conductor;
    public DebugHUD hud;

    void OnCollisionEnter(Collision collision)
    {
        if (!conductor) return;

        // ğŸ”¥ Judging ì¤‘ì—ë„ WrongCut ê°ì§€ (ê¸°ì¡´: IsJudgingì´ë©´ return)
        // PDFì—ì„œëŠ” Non-Judgingì¼ ë•Œë§Œ WrongCutì´ë¼ê³  í–ˆì§€ë§Œ,
        // BlockerëŠ” í•­ìƒ WrongCutìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²Œ ë” í•©ë¦¬ì 

        // WrongCut feedback (debug only)
        if (hud)
        {
            string msg = conductor.IsJudgingWindow()
                ? "WrongCut: Hit blocked area during Judging"
                : "WrongCut: Hit blocked Kimbap (Non-Judging)";
            hud.Log(msg);
        }

        // ğŸ”¥ WrongCut ì´ë²¤íŠ¸ ë°œí–‰
        if (conductor && collision.contacts.Length > 0)
        {
            conductor.NotifyWrongCut(collision.contacts[0].point);
        }
    }
}


/* =====================================================================
   FILE: DebugHUD.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;

public class DebugHUD : MonoBehaviour
{
    RhythmConductor _conductor;
    string _logLine = "";
    float _logTimer;

    public KnifeVelocityEstimator knifeSpeedSource;

    public void Bind(RhythmConductor c) => _conductor = c;

    public void Log(string msg)
    {
        _logLine = msg;
        _logTimer = 2.5f;
        UnityEngine.Debug.Log("[HUD] " + msg);
    }

    void Update()
    {
        if (_logTimer > 0f) _logTimer -= Time.deltaTime;
    }

    void OnGUI()
    {
        if (_conductor == null) return;

        GUIStyle s = new GUIStyle(GUI.skin.label)
        {
            fontSize = 16
        };

        float x = 12, y = 12, w = 640, h = 22;

        GUI.Label(new Rect(x, y, w, h), $"State: {_conductor.State}", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"BGM Time: {_conductor.BgmTime:F3}s", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"Trigger Index: {_conductor.CurrentTriggerIndex}", s); y += h;
        GUI.Label(new Rect(x, y, w, h), $"SliceCount: {_conductor.SliceCount} / {_conductor.RequiredSliceCount}", s); y += h;

        float spd = knifeSpeedSource ? knifeSpeedSource.speed : 0f;
        GUI.Label(new Rect(x, y, w, h), $"Knife Speed: {spd:F2}", s); y += h;

        if (_logTimer > 0f)
        {
            GUI.Label(new Rect(x, y + 8, w, h), $"LOG: {_logLine}", s);
        }
    }
}



/* =====================================================================
   FILE: FeedbackRouter.cs
   ===================================================================== */

using UnityEngine;

public class FeedbackRouter : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public KnifeSlicer knifeSlicer;
    public AudioSource sfxSource;
    public FeedbackSetSO feedbackSet;
    public PlateController plateController;

    float _lastFailFeedbackTime = -999f;

    void OnEnable()
    {
        // ì´ë²¤íŠ¸ êµ¬ë… (ê¸°ì¡´ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ë°œí–‰í•´ì•¼ í•¨)
        if (conductor)
        {
            conductor.OnSliceSuccess.AddListener(HandleSliceSuccess);
            conductor.OnSliceFail.AddListener(HandleSliceFail);
            conductor.OnRoundResult.AddListener(HandleRoundResult);
            conductor.OnWrongCut.AddListener(HandleWrongCut);
        }
    }

    void OnDisable()
    {
        if (conductor)
        {
            conductor.OnSliceSuccess.RemoveListener(HandleSliceSuccess);
            conductor.OnSliceFail.RemoveListener(HandleSliceFail);
            conductor.OnRoundResult.RemoveListener(HandleRoundResult);
            conductor.OnWrongCut.RemoveListener(HandleWrongCut);
        }
    }

    void HandleSliceSuccess(Vector3 hitPos, Vector3 hitNormal, float knifeSpeed)
    {
        if (!feedbackSet) return;

        // SFX (ê¸°ì¡´ KnifeSlicerì—ì„œë„ ì¬ìƒí•˜ì§€ë§Œ ì¤‘ë³µ ë°©ì§€ ê°€ëŠ¥)
        // if (feedbackSet.sfxSliceSuccess && sfxSource)
        //     sfxSource.PlayOneShot(feedbackSet.sfxSliceSuccess);

        // VFX
        if (feedbackSet.vfxSliceSuccessPrefab)
        {
            var vfx = Instantiate(feedbackSet.vfxSliceSuccessPrefab, hitPos, Quaternion.LookRotation(hitNormal));
            Destroy(vfx, 2f);
        }

        // í”Œë ˆì´íŒ… ì¡°ê° ì¶”ê°€
        if (plateController)
            plateController.AddPlatingPiece();
    }

    void HandleSliceFail(Vector3 hitPos, string reason)
    {
        if (!feedbackSet) return;

        // Spam ë°©ì§€
        if (Time.time - _lastFailFeedbackTime < feedbackSet.failCooldown)
            return;
        _lastFailFeedbackTime = Time.time;

        // SFX
        if (feedbackSet.sfxSliceFail && sfxSource)
            sfxSource.PlayOneShot(feedbackSet.sfxSliceFail);

        // VFX
        if (feedbackSet.vfxSliceFailPrefab)
        {
            var vfx = Instantiate(feedbackSet.vfxSliceFailPrefab, hitPos, Quaternion.identity);
            Destroy(vfx, 1.5f);
        }

        // ì•½í•œ í–…í‹± (ì„ íƒ)
        XRHaptics.SendHaptic(true, 0.15f, 0.05f);
    }

    void HandleRoundResult(bool success)
    {
        if (!feedbackSet) return;

        if (success)
        {
            // Success SFX/VFX
            if (feedbackSet.sfxResultSuccess && sfxSource)
                sfxSource.PlayOneShot(feedbackSet.sfxResultSuccess);

            if (feedbackSet.vfxResultSuccessPrefab)
            {
                var vfx = Instantiate(feedbackSet.vfxResultSuccessPrefab, transform.position, Quaternion.identity);
                Destroy(vfx, 3f);
            }

            // ì ‘ì‹œ êµì²´
            if (plateController)
                plateController.ShowSuccessPlate();
        }
        else
        {
            // Fail SFX/VFX
            if (feedbackSet.sfxResultFail && sfxSource)
                sfxSource.PlayOneShot(feedbackSet.sfxResultFail);

            if (feedbackSet.vfxResultFailPrefab)
            {
                var vfx = Instantiate(feedbackSet.vfxResultFailPrefab, transform.position, Quaternion.identity);
                Destroy(vfx, 3f);
            }

            // ì ‘ì‹œ êµì²´
            if (plateController)
                plateController.ShowFailPlate();
        }
    }

    void HandleWrongCut(Vector3 hitPos)
    {
        if (!feedbackSet) return;

        // SFX
        if (feedbackSet.sfxWrongCut && sfxSource)
            sfxSource.PlayOneShot(feedbackSet.sfxWrongCut);

        // VFX
        if (feedbackSet.vfxWrongCutPrefab)
        {
            var vfx = Instantiate(feedbackSet.vfxWrongCutPrefab, hitPos, Quaternion.identity);
            Destroy(vfx, 1.5f);
        }

        // ì§§ì€ ì•½ì§„ë™
        XRHaptics.SendHaptic(true, 0.2f, 0.08f);
    }
}




/* =====================================================================
   FILE: FeedbackSetSO.cs
   ===================================================================== */

using UnityEngine;

[CreateAssetMenu(menuName = "KimbapRhythm/Feedback Set", fileName = "FeedbackSet")]
public class FeedbackSetSO : ScriptableObject
{
    [Header("SFX")]
    public AudioClip sfxSliceSuccess;
    public AudioClip sfxSliceFail;
    public AudioClip sfxResultSuccess;
    public AudioClip sfxResultFail;
    public AudioClip sfxWrongCut;

    [Header("VFX Prefabs")]
    public GameObject vfxSliceSuccessPrefab;
    public GameObject vfxSliceFailPrefab;
    public GameObject vfxResultSuccessPrefab;
    public GameObject vfxResultFailPrefab;
    public GameObject vfxWrongCutPrefab;

    [Header("Plate Prefabs")]
    public GameObject platePrefabEmptyStack;
    public GameObject platePrefabSuccessNeat;
    public GameObject platePrefabFailExplode;

    [Header("Plating Piece")]
    public GameObject platingPiecePrefab;
    public int maxPlatingPiecesPerRound = 12;

    [Header("Input Defaults")]
    public float failCooldown = 0.2f;
    public float skipInputCooldown = 0.5f;
}


/* =====================================================================
   FILE: GameFlowManager.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;

public class GameFlowManager : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public TutorialController tutorialController;
    public RadioClickable radio;
    public PlateController plateController;
    public KimbapSpawner spawner;

    [Header("Data")]
    public RhythmTriggerListSO mainTriggerList;

    bool _mainGameStarted = false; // ğŸ”¥ ë©”ì¸ ê²Œì„ ì‹œì‘ í”Œë˜ê·¸

    void Start()
    {
        // PlateControllerë¥¼ RhythmConductorì— ì—°ê²°
        if (conductor && plateController)
        {
            conductor.plateController = plateController;
        }

        // Spawnerë„ ì—°ê²°
        if (conductor && spawner)
        {
            conductor.spawner = spawner;
        }

        // TutorialControllerì— Radio ì—°ê²°
        if (tutorialController && radio)
        {
            tutorialController.radio = radio;
        }

        // íŠœí† ë¦¬ì–¼ë¶€í„° ì‹œì‘
        if (tutorialController)
        {
            tutorialController.StartTutorial();
        }

        // ë¼ë””ì˜¤ í´ë¦­ ì´ë²¤íŠ¸ êµ¬ë…
        if (radio)
        {
            radio.OnRadioClicked.AddListener(StartMainGame);
        }
    }

    void StartMainGame()
    {
        // ğŸ”¥ ì´ë¯¸ ë©”ì¸ ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìœ¼ë©´ ë¬´ì‹œ
        if (_mainGameStarted)
        {
            UnityEngine.Debug.Log("[GameFlowManager] Main game already started. Ignoring radio click.");
            return;
        }

        UnityEngine.Debug.Log("[GameFlowManager] Starting main game...");

        if (!conductor || !mainTriggerList)
        {
            UnityEngine.Debug.LogError("[GameFlowManager] Missing conductor or mainTriggerList.");
            return;
        }

        // ğŸ”¥ ë©”ì¸ ê²Œì„ ì‹œì‘ í”Œë˜ê·¸ ì„¤ì •
        _mainGameStarted = true;

        // ğŸ”¥ ë¼ë””ì˜¤ ë¹„í™œì„±í™” (ë” ì´ìƒ í´ë¦­ ë¶ˆê°€)
        if (radio)
        {
            radio.SetClickable(false);
        }

        // ğŸ”¥ 1. ê¸°ì¡´ ê¹€ë°¥ ì™„ì „íˆ ì œê±°
        if (spawner)
        {
            spawner.DestroyCurrentKimbap();
            UnityEngine.Debug.Log("[GameFlowManager] Destroyed tutorial kimbap");
        }

        // ğŸ”¥ 2. ì ‘ì‹œ ì´ˆê¸°í™” (ë¹ˆ ì ‘ì‹œë¡œ)
        if (plateController)
        {
            plateController.ResetToEmptyPlate();
            UnityEngine.Debug.Log("[GameFlowManager] Reset plate to empty");
        }

        // ğŸ”¥ 3. ë©”ì¸ ê²Œì„ ë°ì´í„° ì„¤ì •
        conductor.isTutorialMode = false;
        conductor.data = mainTriggerList;

        // ğŸ”¥ 4. ë©”ì¸ ê²Œì„ ì‹œì‘ (ìƒˆ ê¹€ë°¥ ìë™ ìƒì„±ë¨)
        conductor.StartGame();

        UnityEngine.Debug.Log("[GameFlowManager] Main game started successfully!");
    }
}


/* =====================================================================
   FILE: KimbapController.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;

#if EZYSlice
using EzySlice;
#endif

public class KimbapController : MonoBehaviour
{
    public enum AxisMode
    {
        WorldX,             // ì›”ë“œ +X (ì‚¬ì§„ ê¸°ì¤€ ë™ìª½ì„ ì´ê±¸ë¡œ ì“°ëŠ” ê²½ìš°ê°€ ë§ìŒ)
        WorldZ,             // ì›”ë“œ +Z
        ReferenceRight,     // axisReference.right
        ReferenceForward    // axisReference.forward
    }

    [Header("Thin Piece Timing")]
    public float thinFlySeconds = 0.22f;
    public float thinLifeSeconds = 1.2f;

    [Header("Refs")]
    public Collider sliceTrigger;     // Trigger collider (KimbapSliceable layer)
    public Collider blockCollider;    // Solid collider (KimbapBlocked layer)
    public Transform mainMeshRoot;    // Mesh-only object (ì—†ìœ¼ë©´ ëŸ°íƒ€ì„ì— ìë™ ìƒì„±/ë¶„ë¦¬)
    public Material crossSectionMaterial;

    [Header("Slice Direction")]
    public AxisMode axisMode = AxisMode.WorldX;
    public Transform axisReference;   // í…Œì´ë¸” ê°™ì€ ê¸°ì¤€ Transform (Reference ëª¨ë“œì—ì„œ ì‚¬ìš©)
    public bool invertAxis = false;

    [Header("Debug")]
    public bool debugDrawPlane = true;
    public float debugDrawSeconds = 0.25f;

    [Header("Runtime")]
    public bool sliceable;

    RhythmTriggerListSO.Trigger _trigger;

    // current mesh GO (í•­ìƒ "ë©”ì‰¬ ì „ìš©" ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ë¦¬í‚¤ê²Œ ìœ ì§€)
    GameObject _currentMeshGO;

    int _activeThinPieces;

    void Awake()
    {
        // ê¸°ë³¸ì€ ë§‰í˜
        SetSliceable(false);

        // ë£¨íŠ¸ì— Meshê°€ ë¶™ì–´ìˆìœ¼ë©´ ëŸ°íƒ€ì„ì— ë©”ì‰¬ ì „ìš© ìì‹ìœ¼ë¡œ ë¶„ë¦¬
        EnsureMeshRoot();

        _currentMeshGO = FindMeshGameObject(mainMeshRoot);
        if (_currentMeshGO == null)
            UnityEngine.Debug.LogWarning("[KimbapController] MeshFilter not found under mainMeshRoot.");
    }

    public void BeginTrigger(RhythmTriggerListSO.Trigger trigger)
    {
        _trigger = trigger;
        _activeThinPieces = 0;

        EnsureMeshRoot();
        _currentMeshGO = FindMeshGameObject(mainMeshRoot);
        SetSliceable(false);
    }

    public void SetSliceable(bool value)
    {
        sliceable = value;
        if (sliceTrigger) sliceTrigger.enabled = value;
        if (blockCollider) blockCollider.enabled = !value;
    }

    public void OnTriggerResult(bool success)
    {
        UnityEngine.Debug.Log($"[KimbapController] Trigger result: {(success ? "SUCCESS" : "FAIL")}");
    }

    public bool CanSpawnThinPiece()
    {
        if (_trigger == null) return true;
        return _activeThinPieces < Mathf.Max(1, _trigger.maxActiveThinPieces);
    }

    public void NotifyThinPieceSpawned() => _activeThinPieces++;
    public void NotifyThinPieceDespawned() => _activeThinPieces = Mathf.Max(0, _activeThinPieces - 1);

    Vector3 GetCutAxis()
    {
        Vector3 axis = Vector3.right;

        switch (axisMode)
        {
            case AxisMode.WorldX: axis = Vector3.right; break;
            case AxisMode.WorldZ: axis = Vector3.forward; break;
            case AxisMode.ReferenceRight:
                axis = axisReference ? axisReference.right : Vector3.right;
                break;
            case AxisMode.ReferenceForward:
                axis = axisReference ? axisReference.forward : Vector3.forward;
                break;
        }

        axis = axis.normalized;
        if (invertAxis) axis = -axis;
        return axis;
    }

    /// <summary>
    /// ì‚¬ì§„ ê¸°ì¤€ "ë™ìª½(=Axis)"ì—ì„œ ì–‡ê²Œ í•œ ì¥ì”© ë–¼ì–´ë‚´ëŠ” ì ˆë‹¨.
    /// sliceIndex0BasedëŠ” thin thickness curveìš©.
    /// </summary>
    public bool ExecuteRightThinSlice(int sliceIndex0Based)
    {
#if !EZYSlice
        UnityEngine.Debug.LogWarning("[KimbapController] EZYSlice not enabled. Add EzySlice and define scripting symbol EZYSlice.");
        return false;
#else
        if (_trigger == null)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] No trigger bound.");
            return false;
        }

        EnsureMeshRoot();

        if (_currentMeshGO == null)
        {
            _currentMeshGO = FindMeshGameObject(mainMeshRoot);
            if (_currentMeshGO == null)
            {
                UnityEngine.Debug.LogWarning("[KimbapController] Mesh object not found.");
                return false;
            }
        }

        var rend = _currentMeshGO.GetComponentInChildren<Renderer>();
        if (!rend)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] Renderer not found on mesh.");
            return false;
        }

        // ì ˆë‹¨ ì¶•(ì‚¬ì§„ ê¸°ì¤€ ë™ìª½)
        Vector3 axis = GetCutAxis();

        // thickness ê³„ì‚°
        float tNorm = _trigger.thinSliceThicknessNorm;
        if (_trigger.thinThicknessCurve != null && _trigger.thinThicknessCurve.length > 0 && _trigger.requiredSliceCount > 1)
        {
            float u = sliceIndex0Based / (float)(_trigger.requiredSliceCount - 1);
            float cu = _trigger.thinThicknessCurve.Evaluate(u);
            if (cu > 0f) tNorm = cu;
        }

        Bounds wb = rend.bounds;

        // bounds cornersë¥¼ axisì— íˆ¬ì˜í•´ì„œ ê¸¸ì´ ì¸¡ì •
        GetMinMaxAlongDir(wb, axis, out float minD, out float maxD);
        float lengthAlongAxis = Mathf.Max(0.0001f, maxD - minD);

        float thinWorld = Mathf.Max(lengthAlongAxis * tNorm, _trigger.minThinThicknessWorld);

        // "ë™ìª½ ë" (axis ë°©í–¥ì˜ max ìª½)
        // AABBëŠ” axis ë°©í–¥ìœ¼ë¡œ center ê¸°ì¤€ ëŒ€ì¹­ì´ë¯€ë¡œ ì•„ë˜ ë°©ì‹ì´ ì•ˆì •ì 
        Vector3 axisEnd = wb.center + axis * (lengthAlongAxis * 0.5f);

        // axisEndì—ì„œ thinWorldë§Œí¼ ì•ˆìª½ìœ¼ë¡œ ë“¤ì–´ì˜¨ ì§€ì ì— ì ˆë‹¨ í‰ë©´ ìƒì„±
        Vector3 planePoint = axisEnd - axis * thinWorld;
        Vector3 planeNormal = axis; // normalì´ axis ìª½ì„ í–¥í•˜ë©´ axisEnd ìª½ ì¡°ê°ì´ ì–‡ê²Œ ë–¨ì–´ì§

        if (debugDrawPlane)
        {
           UnityEngine.Debug.DrawRay(planePoint, planeNormal * 0.2f, Color.green, debugDrawSeconds);
            UnityEngine.Debug.DrawRay(planePoint, -planeNormal * 0.2f, Color.red, debugDrawSeconds);
        }

        // ìŠ¬ë¼ì´ìŠ¤ëŠ” "ë©”ì‰¬ ì „ìš© ì˜¤ë¸Œì íŠ¸"ë§Œ ëŒ€ìƒìœ¼ë¡œ!
        // (ë£¨íŠ¸ëŠ” ì ˆëŒ€ Destroy í•˜ë©´ ì•ˆ ë¨)
        Transform meshT = _currentMeshGO.transform;

        // ë£¨íŠ¸ ê¸°ì¤€ ë¡œì»¬ í¬ì¦ˆ ì €ì¥(ìŠ¬ë¼ì´ìŠ¤ í›„ì—ë„ ë™ì¼ í¬ì¦ˆ ìœ ì§€)
        Transform root = transform;
        Vector3 localPos = root.InverseTransformPoint(meshT.position);
        Quaternion localRot = Quaternion.Inverse(root.rotation) * meshT.rotation;
        Vector3 localScale = meshT.localScale;

        // ì‹¤ì œ ìŠ¬ë¼ì´ìŠ¤
        var hull = _currentMeshGO.Slice(planePoint, planeNormal, crossSectionMaterial);
        if (hull == null)
        {
            UnityEngine.Debug.LogWarning("[KimbapController] Slice returned null (failed). Try enabling Read/Write on mesh import, or adjust axis.");
            return false;
        }

        GameObject upper = hull.CreateUpperHull(_currentMeshGO, crossSectionMaterial);
        GameObject lower = hull.CreateLowerHull(_currentMeshGO, crossSectionMaterial);

        if (!upper || !lower)
        {
            if (upper) Destroy(upper);
            if (lower) Destroy(lower);
            UnityEngine.Debug.LogWarning("[KimbapController] Hull create failed.");
            return false;
        }

        // big/small ì„ íƒ(ë” í° ìª½ì´ ë³¸ì²´)
        float vu = BoundsVolume(upper);
        float vl = BoundsVolume(lower);
        GameObject big = (vu >= vl) ? upper : lower;
        GameObject small = (big == upper) ? lower : upper;

        // ê¸°ì¡´ ë©”ì‰¬ ì˜¤ë¸Œì íŠ¸ ì œê±°
        Destroy(_currentMeshGO);

        // big/smallì„ ë£¨íŠ¸ ì•„ë˜ë¡œ ë¶™ì´ê³  ë¡œì»¬ í¬ì¦ˆ ë³µì›
        big.name = "MainMeshRuntime";
        big.transform.SetParent(root, false);
        big.transform.localPosition = localPos;
        big.transform.localRotation = localRot;
        big.transform.localScale = localScale;

        small.transform.SetParent(root, false);
        small.transform.localPosition = localPos;
        small.transform.localRotation = localRot;
        small.transform.localScale = localScale;

        // í˜„ì¬ ë©”ì‰¬ ê°±ì‹ 
        mainMeshRoot = big.transform;
        _currentMeshGO = big;

        // ì–‡ì€ ì¡°ê° ì—°ì¶œ
        if (CanSpawnThinPiece())
        {
            NotifyThinPieceSpawned();

            var tp = small.AddComponent<ThinPieceAutoCleanup>();
            tp.owner = this;
            tp.flyDirection = axis;     // ë™ìª½ìœ¼ë¡œ ì‚´ì§ íŠ•ê¸°ê¸°
            tp.flySeconds = 0.22f;
            tp.lifeSeconds = 1.2f;

            foreach (var c in small.GetComponentsInChildren<Collider>())
                c.enabled = false;
        }
        else
        {
            Destroy(small);
        }

        return true;
#endif
    }

    // --- í•µì‹¬: ë£¨íŠ¸ì— Meshê°€ ë¶™ì–´ìˆìœ¼ë©´ ë©”ì‰¬ë§Œ ìì‹ìœ¼ë¡œ ë¶„ë¦¬í•´ì„œ "ë£¨íŠ¸ íŒŒê´´" ë°©ì§€ ---
    void EnsureMeshRoot()
    {
        if (mainMeshRoot && FindMeshGameObject(mainMeshRoot)) return;

        // ë£¨íŠ¸ì— Meshê°€ ë¶™ì–´ ìˆìœ¼ë©´ ëŸ°íƒ€ì„ ë³µì œí•´ì„œ ìì‹ìœ¼ë¡œ ë¶„ë¦¬
        var mf = GetComponent<MeshFilter>();
        var mr = GetComponent<MeshRenderer>();
        if (mf && mr)
        {
            var go = new GameObject("MainMeshRuntime");
            go.transform.SetParent(transform, false);
            go.transform.localPosition = Vector3.zero;
            go.transform.localRotation = Quaternion.identity;
            go.transform.localScale = Vector3.one;

            var newMf = go.AddComponent<MeshFilter>();
            newMf.sharedMesh = mf.sharedMesh;

            var newMr = go.AddComponent<MeshRenderer>();
            newMr.sharedMaterials = mr.sharedMaterials;

            // ë£¨íŠ¸ MeshRendererëŠ” êº¼ë‘ê¸°(ì½œë¼ì´ë”/ìŠ¤í¬ë¦½íŠ¸ëŠ” ìœ ì§€)
            mr.enabled = false;
            mf.mesh = null;

            mainMeshRoot = go.transform;
            _currentMeshGO = go;
            return;
        }

        // ë£¨íŠ¸ì— Meshê°€ ì—†ë‹¤ë©´(ì´ë¯¸ ìì‹ êµ¬ì¡°ì¼ ìˆ˜ë„)
        // mainMeshRootë¥¼ ë£¨íŠ¸ë¡œ ë‘ê³  ê²€ìƒ‰
        if (!mainMeshRoot) mainMeshRoot = transform;
    }

    static GameObject FindMeshGameObject(Transform root)
    {
        if (!root) return null;
        var mfSelf = root.GetComponent<MeshFilter>();
        if (mfSelf) return mfSelf.gameObject;
        var mf = root.GetComponentInChildren<MeshFilter>();
        return mf ? mf.gameObject : null;
    }

    static float BoundsVolume(GameObject go)
    {
        var r = go.GetComponentInChildren<Renderer>();
        if (!r) return 0f;
        var b = r.bounds;
        return b.size.x * b.size.y * b.size.z;
    }

    static void GetMinMaxAlongDir(Bounds b, Vector3 dir, out float min, out float max)
    {
        dir.Normalize();
        Vector3 c = b.center;
        Vector3 e = b.extents;

        Vector3[] corners = new Vector3[8]
        {
            c + new Vector3( e.x,  e.y,  e.z),
            c + new Vector3( e.x,  e.y, -e.z),
            c + new Vector3( e.x, -e.y,  e.z),
            c + new Vector3( e.x, -e.y, -e.z),
            c + new Vector3(-e.x,  e.y,  e.z),
            c + new Vector3(-e.x,  e.y, -e.z),
            c + new Vector3(-e.x, -e.y,  e.z),
            c + new Vector3(-e.x, -e.y, -e.z),
        };

        min = float.PositiveInfinity;
        max = float.NegativeInfinity;

        for (int i = 0; i < corners.Length; i++)
        {
            float d = Vector3.Dot(corners[i], dir);
            if (d < min) min = d;
            if (d > max) max = d;
        }
    }
}



/* =====================================================================
   FILE: KimbapSliceTarget.cs
   ===================================================================== */

using UnityEngine;

public class KimbapSliceTarget : MonoBehaviour
{
    public KimbapController controller;

    void Awake()
    {
        if (!controller) controller = GetComponentInParent<KimbapController>();
    }
}



/* =====================================================================
   FILE: KimbapSpawner.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;

public class KimbapSpawner : MonoBehaviour
{
    public KimbapController kimbapPrefab;
    public Transform spawnPoint;

    public KimbapController CurrentKimbap { get; private set; }

    public void EnsureKimbapExists()
    {
        if (CurrentKimbap) return;
        SpawnNew();
    }

    public void SpawnNew()
    {
        if (!kimbapPrefab)
        {
            UnityEngine.Debug.LogError("[KimbapSpawner] Missing kimbapPrefab.");
            return;
        }

        Vector3 pos = spawnPoint ? spawnPoint.position : transform.position;
        Quaternion rot = spawnPoint ? spawnPoint.rotation : transform.rotation;

        CurrentKimbap = Instantiate(kimbapPrefab, pos, rot);
    }

    // ğŸ”¥ ìƒˆë¡œ ì¶”ê°€: ê¸°ì¡´ ê¹€ë°¥ ì œê±°
    public void DestroyCurrentKimbap()
    {
        if (CurrentKimbap)
        {
            Destroy(CurrentKimbap.gameObject);
            CurrentKimbap = null;
        }
    }
}


/* =====================================================================
   FILE: KnifePhysicsFollowerOVR.cs
   ===================================================================== */

using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class KnifePhysicsFollowerOVR : MonoBehaviour
{
    public Transform target;
    public Rigidbody rb;

    [Range(0.01f, 1f)] public float positionLerp = 0.5f;
    [Range(0.01f, 1f)] public float rotationLerp = 0.35f;
    public float maxMoveSpeed = 12f;
    public float maxTurnSpeed = 480f;

    Vector3 _targetPos;
    Quaternion _targetRot;
    bool _hasTargetPose;

    void Awake()
    {
        if (!rb) rb = GetComponent<Rigidbody>();
    }

    void Update()
    {
        if (!target) return;
        _targetPos = target.position;
        _targetRot = target.rotation;
        _hasTargetPose = true;
    }

    void FixedUpdate()
    {
        if (!rb || !_hasTargetPose) return;

        // --- Position ---
        Vector3 delta = _targetPos - rb.position;
        float maxStep = maxMoveSpeed * Time.fixedDeltaTime;
        Vector3 step = Vector3.ClampMagnitude(delta, maxStep);
        Vector3 nextPos = rb.position + step;
        nextPos = Vector3.Lerp(rb.position, nextPos, positionLerp);
        rb.MovePosition(nextPos);

        // --- Rotation ---
        Quaternion desiredRot = _targetRot;

        Quaternion dq = desiredRot * Quaternion.Inverse(rb.rotation);
        dq.ToAngleAxis(out float angle, out Vector3 axis);
        if (angle > 180f) angle -= 360f;

        float maxAngleStep = maxTurnSpeed * Time.fixedDeltaTime;
        float clamped = Mathf.Clamp(angle, -maxAngleStep, maxAngleStep);
        Quaternion stepRot = Quaternion.AngleAxis(clamped, axis);

        Quaternion nextRot = stepRot * rb.rotation;
        nextRot = Quaternion.Slerp(rb.rotation, nextRot, rotationLerp);
        rb.MoveRotation(nextRot);
    }
}



/* =====================================================================
   FILE: KnifeSlicer.cs
   ===================================================================== */

using UnityEngine;

public class KnifeSlicer : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public KnifeVelocityEstimator velocityEstimator;
    public KnifeVisualResistance visualResistance;

    [Header("Hand")]
    public bool rightHand = true;

    [Header("Audio")]
    public AudioSource sfxSource;

    [Header("Slice Prevention (ì¤‘ë³µ ë°©ì§€)")]
    [Tooltip("ìë¥´ê¸° í›„ ë‹¤ìŒ ìë¥´ê¸°ê¹Œì§€ ìµœì†Œ ëŒ€ê¸° ì‹œê°„ (ì´ˆ)")]
    public float sliceCooldown = 0.15f;

    [Tooltip("ì—°ì†ìœ¼ë¡œ ê°™ì€ ê¹€ë°¥ì„ ìë¥¼ ìˆ˜ ìˆëŠ” ìµœì†Œ ê°„ê²© (ì´ˆ)")]
    public float sameKimbapCooldown = 0.1f;

    // attempt lock
    bool _canSlice = true;
    float _contactMs;
    float _lastSliceTime = -999f;

    KimbapController _currentKimbap;
    KimbapController _lastSlicedKimbap;
    float _lastKimbapSliceTime = -999f;

    int _sliceIndexThisTrigger;

    // ğŸ”¥ ì‹¤íŒ¨ í”¼ë“œë°± ì¿¨ë‹¤ìš´
    float _lastFailFeedbackTime = -999f;
    const float FAIL_FEEDBACK_COOLDOWN = 0.2f;

    void Awake()
    {
        if (!sfxSource) sfxSource = gameObject.AddComponent<AudioSource>();
    }

    void Update()
    {
        // Reset per-trigger index when trigger changes
        if (!conductor) return;

        // If not judging, allow slice again but don't keep old target
        if (!conductor.IsJudgingWindow())
        {
            _canSlice = true;
            _contactMs = 0f;
            _currentKimbap = null;
            _sliceIndexThisTrigger = 0;
            return;
        }
    }

    void OnTriggerEnter(Collider other)
    {
        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target || !target.controller) return;

        _currentKimbap = target.controller;
        _contactMs = 0f;
    }

    void OnTriggerStay(Collider other)
    {
        if (!conductor || !conductor.IsJudgingWindow()) return;

        // ğŸ”¥ ì¿¨ë‹¤ìš´ ì²´í¬ (ì¤‘ë³µ ë°©ì§€)
        if (Time.time - _lastSliceTime < sliceCooldown)
        {
            return;
        }

        if (!_canSlice) return;

        var trigger = conductor.GetCurrentTrigger();
        if (trigger == null) return;

        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target || !target.controller) return;

        // ğŸ”¥ ê°™ì€ ê¹€ë°¥ ì—°ì† ìë¥´ê¸° ë°©ì§€
        if (target.controller == _lastSlicedKimbap)
        {
            if (Time.time - _lastKimbapSliceTime < sameKimbapCooldown)
            {
                return;
            }
        }

        // Must be sliceable state
        if (!target.controller.sliceable) return;

        // Contact time
        _contactMs += Time.deltaTime * 1000f;
        if (_contactMs < trigger.minContactMs)
        {
            // ğŸ”¥ ì ‘ì´‰ ì‹œê°„ ë¶€ì¡± - í”¼ë“œë°± ì—†ì´ ê·¸ëƒ¥ ë¦¬í„´
            return;
        }

        // ğŸ”¥ Speed check (í•µì‹¬!)
        float speed = velocityEstimator ? velocityEstimator.speed : 0f;

        if (speed < trigger.minKnifeSpeed)
        {
            // ğŸ”¥ ì†ë„ ë¶€ì¡± - ì‹¤íŒ¨ í”¼ë“œë°± (spam ë°©ì§€)
            if (Time.time - _lastFailFeedbackTime >= FAIL_FEEDBACK_COOLDOWN)
            {
                _lastFailFeedbackTime = Time.time;

                // ë””ë²„ê·¸ ë¡œê·¸
                UnityEngine.Debug.Log($"[KnifeSlicer] Speed too low: {speed:F2} < {trigger.minKnifeSpeed:F2}");

                if (conductor)
                {
                    conductor.NotifySliceFail(transform.position, "SpeedTooLow");
                }
            }
            return;
        }

        // ğŸ”¥ ì†ë„ ì¶©ë¶„! - VALID SLICE!
        UnityEngine.Debug.Log($"[KnifeSlicer] Valid slice! Speed: {speed:F2} >= {trigger.minKnifeSpeed:F2}");

        _canSlice = false;
        _lastSliceTime = Time.time;
        _lastSlicedKimbap = target.controller;
        _lastKimbapSliceTime = Time.time;

        // 1) register count
        conductor.RegisterValidSlice();

        // 2) feedback
        float amp = Mathf.Lerp(trigger.hapticHitBase, trigger.hapticHitMax,
            Mathf.Clamp01(speed / (trigger.minKnifeSpeed * 2f)));
        XRHaptics.SendHaptic(rightHand, amp, trigger.hapticDurationMs / 1000f);
        // second tap
        XRHaptics.SendHaptic(rightHand, amp * 0.85f, Mathf.Max(0.01f, trigger.hapticDurationMs / 1600f));

        if (trigger.impactSound) sfxSource.PlayOneShot(trigger.impactSound);

        if (visualResistance)
            visualResistance.Play(trigger.visualResistanceMs, trigger.visualResistanceStrength);

        if (trigger.cutVfxPrefab)
        {
            // spawn at contact approx (knife trigger position)
            var vfx = GameObject.Instantiate(trigger.cutVfxPrefab, transform.position, Quaternion.identity);
            GameObject.Destroy(vfx, 1.5f);
        }

        // 3) RightThin slice (EzySlice)
        if (_currentKimbap)
        {
            int idx0 = _sliceIndexThisTrigger;
            _sliceIndexThisTrigger++;
            _currentKimbap.ExecuteRightThinSlice(idx0);
        }

        // ğŸ”¥ 4) ì„±ê³µ ì´ë²¤íŠ¸ ë°œí–‰
        if (conductor)
        {
            // ë²•ì„ ì€ ìœ„ìª½(ê¹€ë°¥ ë‹¨ë©´)ìœ¼ë¡œ ê°€ì •
            conductor.NotifySliceSuccess(transform.position, Vector3.up, speed);
        }

        // Unlock after short cooldown (prevents multi-count in same swing)
        Invoke(nameof(UnlockSlice), sliceCooldown);
    }

    void OnTriggerExit(Collider other)
    {
        var target = other.GetComponentInParent<KimbapSliceTarget>();
        if (!target) return;

        _contactMs = 0f;

        // exit allows next slice sooner (but still respects cooldown)
        if (conductor && conductor.IsJudgingWindow())
        {
            // ì¿¨ë‹¤ìš´ì´ ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ í—ˆìš©
            if (Time.time - _lastSliceTime >= sliceCooldown)
            {
                _canSlice = true;
            }
        }
    }

    void UnlockSlice()
    {
        _contactMs = 0f;
        _canSlice = true;
    }
}


/* =====================================================================
   FILE: KnifeVelocityEstimator.cs
   ===================================================================== */

using UnityEngine;

public class KnifeVelocityEstimator : MonoBehaviour
{
    public Transform samplePoint; // blade tip or knife root
    public float speed { get; private set; }

    Vector3 _prevPos;
    bool _hasPrev;

    void Start()
    {
        if (!samplePoint) samplePoint = transform;
    }

    void Update()
    {
        Vector3 p = samplePoint.position;
        if (_hasPrev)
        {
            float dt = Mathf.Max(Time.deltaTime, 0.0001f);
            speed = Vector3.Distance(p, _prevPos) / dt;
        }
        _prevPos = p;
        _hasPrev = true;
    }
}



/* =====================================================================
   FILE: KnifeVisualResistance.cs
   ===================================================================== */

using UnityEngine;

public class KnifeVisualResistance : MonoBehaviour
{
    public Transform knifeVisual; // assign model root
    public Vector3 localBackAxis = Vector3.back; // visual moves slightly backward on hit
    public float maxOffset = 0.015f;

    float _timer;
    float _dur;
    float _strength;
    Vector3 _baseLocalPos;

    void Awake()
    {
        if (!knifeVisual) knifeVisual = transform;
        _baseLocalPos = knifeVisual.localPosition;
    }

    public void Play(int milliseconds, float strength01)
    {
        _dur = Mathf.Clamp(milliseconds / 1000f, 0.03f, 0.25f);
        _timer = _dur;
        _strength = Mathf.Clamp01(strength01);
    }

    void LateUpdate()
    {
        if (_timer <= 0f)
        {
            knifeVisual.localPosition = Vector3.Lerp(knifeVisual.localPosition, _baseLocalPos, 0.35f);
            return;
        }

        _timer -= Time.deltaTime;
        float u = 1f - Mathf.Clamp01(_timer / _dur); // 0->1
        // ease in/out
        float k = Mathf.Sin(u * Mathf.PI);
        Vector3 offset = localBackAxis.normalized * (maxOffset * _strength * k);
        knifeVisual.localPosition = _baseLocalPos + offset;
    }
}



/* =====================================================================
   FILE: PlateController.cs
   ===================================================================== */

// PlateController.cs (ì¡°ê° ì •ë¦¬ ìˆ˜ì •)
using System;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine;

public class PlateController : MonoBehaviour
{
    [Header("Refs")]
    public FeedbackSetSO feedbackSet;
    public Transform plateSpawnPoint;

    [Header("Stack Layout (12 pieces: 8+4)")]
    public float pieceRadius = 0.04f;
    public float pieceThickness = 0.015f;
    public float ringRadius0 = 0.054f;  // pieceRadius * 1.35
    public float ringRadius1 = 0.034f;  // pieceRadius * 0.85
    public float layerHeight = 0.01275f; // pieceThickness * 0.85
    public float posJitter = 0.0032f;   // pieceRadius * 0.08
    public float yawJitter = 10f;       // degrees
    public float tiltJitter = 6f;       // degrees

    GameObject _currentPlate;
    List<GameObject> _platingPieces = new List<GameObject>();
    int _stackCount = 0;

    // ê³ ì • ë ˆì´ì•„ì›ƒ: 1ì¸µ 8ê°œ(ë§) + 2ì¸µ 4ê°œ(ë‚´ë¶€)
    static readonly Vector2[] _layer0Offsets = new Vector2[8]
    {
        new Vector2(1f, 0f),
        new Vector2(0.707f, 0.707f),
        new Vector2(0f, 1f),
        new Vector2(-0.707f, 0.707f),
        new Vector2(-1f, 0f),
        new Vector2(-0.707f, -0.707f),
        new Vector2(0f, -1f),
        new Vector2(0.707f, -0.707f)
    };

    static readonly Vector2[] _layer1Offsets = new Vector2[4]
    {
        new Vector2(0.707f, 0f),
        new Vector2(0f, 0.707f),
        new Vector2(-0.707f, 0f),
        new Vector2(0f, -0.707f)
    };

    void Start()
    {
        ResetToEmptyPlate();
    }

    public void ResetToEmptyPlate()
    {
        UnityEngine.Debug.Log("[PlateController] ResetToEmptyPlate called");

        ClearCurrentPlate();
        ClearPlatingPieces(); // ğŸ”¥ ì¡°ê°ë“¤ë„ ì •ë¦¬

        if (feedbackSet && feedbackSet.platePrefabEmptyStack)
        {
            Vector3 pos = plateSpawnPoint ? plateSpawnPoint.position : transform.position;
            Quaternion rot = plateSpawnPoint ? plateSpawnPoint.rotation : transform.rotation;
            _currentPlate = Instantiate(feedbackSet.platePrefabEmptyStack, pos, rot);
        }

        _stackCount = 0;
    }

    public void ShowSuccessPlate()
    {
        UnityEngine.Debug.Log("[PlateController] ShowSuccessPlate called");

        ClearCurrentPlate();
        ClearPlatingPieces(); // ğŸ”¥ ì¡°ê°ë“¤ ì •ë¦¬ ì¶”ê°€

        if (feedbackSet && feedbackSet.platePrefabSuccessNeat)
        {
            Vector3 pos = plateSpawnPoint ? plateSpawnPoint.position : transform.position;
            Quaternion rot = plateSpawnPoint ? plateSpawnPoint.rotation : transform.rotation;
            _currentPlate = Instantiate(feedbackSet.platePrefabSuccessNeat, pos, rot);
        }
    }

    public void ShowFailPlate()
    {
        UnityEngine.Debug.Log("[PlateController] ShowFailPlate called");

        ClearCurrentPlate();
        ClearPlatingPieces(); // ğŸ”¥ ì¡°ê°ë“¤ ì •ë¦¬ ì¶”ê°€

        if (feedbackSet && feedbackSet.platePrefabFailExplode)
        {
            Vector3 pos = plateSpawnPoint ? plateSpawnPoint.position : transform.position;
            Quaternion rot = plateSpawnPoint ? plateSpawnPoint.rotation : transform.rotation;
            _currentPlate = Instantiate(feedbackSet.platePrefabFailExplode, pos, rot);

            // í”„ë¦¬íŒ¹ ë‚´ë¶€ì— í­ë°œ ì• ë‹ˆ/SFX ìˆë‹¤ë©´ ì—¬ê¸°ì„œ íŠ¸ë¦¬ê±°
            var anim = _currentPlate.GetComponent<Animator>();
            if (anim) anim.SetTrigger("Explode");
        }
    }

    public void AddPlatingPiece()
    {
        if (!feedbackSet || !feedbackSet.platingPiecePrefab)
        {
            UnityEngine.Debug.LogWarning("[PlateController] feedbackSet or platingPiecePrefab is null!");
            return;
        }

        if (_stackCount >= feedbackSet.maxPlatingPiecesPerRound)
        {
            UnityEngine.Debug.LogWarning($"[PlateController] Stack full! {_stackCount}/{feedbackSet.maxPlatingPiecesPerRound}");
            return;
        }

        Vector3 basePos = plateSpawnPoint ? plateSpawnPoint.position : transform.position;
        Quaternion baseRot = plateSpawnPoint ? plateSpawnPoint.rotation : transform.rotation;

        // ë ˆì´ì•„ì›ƒ ê³„ì‚°
        int layer = (_stackCount < 8) ? 0 : 1;
        int indexInLayer = (_stackCount < 8) ? _stackCount : (_stackCount - 8);

        Vector2 offset2D = (layer == 0)
            ? _layer0Offsets[indexInLayer] * ringRadius0
            : _layer1Offsets[indexInLayer] * ringRadius1;

        float yPos = layer * layerHeight;

        // Jitter
        Vector3 jitterPos = new Vector3(
            UnityEngine.Random.Range(-posJitter, posJitter),
            0f,
            UnityEngine.Random.Range(-posJitter, posJitter)
        );

        Vector3 localPos = new Vector3(offset2D.x, yPos, offset2D.y) + jitterPos;
        Vector3 worldPos = basePos + baseRot * localPos;

        // Rotation jitter
        Quaternion jitterRot = Quaternion.Euler(
            UnityEngine.Random.Range(-tiltJitter, tiltJitter),
            UnityEngine.Random.Range(-yawJitter, yawJitter),
            UnityEngine.Random.Range(-tiltJitter, tiltJitter)
        );

        Quaternion worldRot = baseRot * jitterRot;

        // ìƒì„±
        GameObject piece = Instantiate(feedbackSet.platingPiecePrefab, worldPos, worldRot);
        _platingPieces.Add(piece);
        _stackCount++;

        UnityEngine.Debug.Log($"[PlateController] Plating piece #{_stackCount} spawned at {worldPos}");
    }

    void ClearCurrentPlate()
    {
        if (_currentPlate)
        {
            UnityEngine.Debug.Log("[PlateController] Destroying current plate");
            Destroy(_currentPlate);
            _currentPlate = null;
        }
    }

    void ClearPlatingPieces()
    {
        UnityEngine.Debug.Log($"[PlateController] Clearing {_platingPieces.Count} plating pieces");

        foreach (var p in _platingPieces)
        {
            if (p) Destroy(p);
        }
        _platingPieces.Clear();
        _stackCount = 0;
    }
}


/* =====================================================================
   FILE: RadioClickable.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;
using UnityEngine.Events;

public class RadioClickable : MonoBehaviour
{
    [Header("Events")]
    public UnityEvent OnRadioClicked;

    [Header("VR Setup")]
    public Transform rightHandAnchor; // OVRCameraRigì˜ RightHandAnchor í• ë‹¹

    [Header("Visual Feedback (Optional)")]
    public Renderer radioRenderer;
    public Material activeMaterial;   // í´ë¦­ ê°€ëŠ¥í•  ë•Œ ë¨¸í‹°ë¦¬ì–¼
    public Material inactiveMaterial; // í´ë¦­ ë¶ˆê°€ëŠ¥í•  ë•Œ ë¨¸í‹°ë¦¬ì–¼

    bool _tutorialCompleted = false;
    bool _clickable = false; // ğŸ”¥ í´ë¦­ ê°€ëŠ¥ ì—¬ë¶€

    void Start()
    {
        // ì´ˆê¸° ìƒíƒœ: í´ë¦­ ë¶ˆê°€
        UpdateVisuals();
    }

    public void SetTutorialCompleted(bool completed)
    {
        _tutorialCompleted = completed;

        if (completed)
        {
            UnityEngine.Debug.Log("[RadioClickable] Tutorial completed - Radio can now be enabled");
        }
    }

    // ğŸ”¥ í´ë¦­ ê°€ëŠ¥ ì—¬ë¶€ ì„¤ì •
    public void SetClickable(bool clickable)
    {
        _clickable = clickable;
        UnityEngine.Debug.Log($"[RadioClickable] Clickable set to: {clickable}");
        UpdateVisuals();
    }

    void UpdateVisuals()
    {
        // ë¹„ì£¼ì–¼ í”¼ë“œë°± (ì„ íƒì‚¬í•­)
        if (radioRenderer && activeMaterial && inactiveMaterial)
        {
            radioRenderer.material = _clickable ? activeMaterial : inactiveMaterial;
        }
    }

    void OnMouseDown()
    {
        // ğŸ”¥ í´ë¦­ ê°€ëŠ¥ ìƒíƒœê°€ ì•„ë‹ˆë©´ ë¬´ì‹œ
        if (!_clickable)
        {
            UnityEngine.Debug.Log("[RadioClickable] Radio not clickable yet.");
            return;
        }

        UnityEngine.Debug.Log("[RadioClickable] Radio clicked! Starting main game...");

        // ğŸ”¥ í´ë¦­ í›„ ì¦‰ì‹œ ë¹„í™œì„±í™” (1íšŒë§Œ í´ë¦­)
        _clickable = false;
        UpdateVisuals();

        OnRadioClicked?.Invoke();
    }

    // VRìš© ë ˆì´ìºìŠ¤íŠ¸ ì²˜ë¦¬
    void Update()
    {
        // ğŸ”¥ í´ë¦­ ê°€ëŠ¥ ìƒíƒœê°€ ì•„ë‹ˆë©´ ë¬´ì‹œ
        if (!_clickable) return;

        // A ë²„íŠ¼ (Primary Index Trigger) ëˆŒë €ì„ ë•Œ
        if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
        {
            // ğŸ”¥ ë°©ë²• 1: RightHandAnchor ì‚¬ìš© (ê¶Œì¥)
            if (rightHandAnchor)
            {
                Ray ray = new Ray(rightHandAnchor.position, rightHandAnchor.forward);

                if (Physics.Raycast(ray, out RaycastHit hit, 2f))
                {
                    UnityEngine.Debug.Log($"[RadioClickable] VR Raycast hit: {hit.collider.gameObject.name}");

                    if (hit.collider.gameObject == gameObject)
                    {
                        UnityEngine.Debug.Log("[RadioClickable] Radio clicked via VR!");

                        // ğŸ”¥ í´ë¦­ í›„ ì¦‰ì‹œ ë¹„í™œì„±í™” (1íšŒë§Œ í´ë¦­)
                        _clickable = false;
                        UpdateVisuals();

                        OnRadioClicked?.Invoke();
                    }
                }
            }
            // ğŸ”¥ ë°©ë²• 2: OVRInput ì‚¬ìš© (fallback)
            else
            {
                Vector3 pos = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch);
                Quaternion rot = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch);

                // âš ï¸ ë¡œì»¬ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜ í•„ìš”
                // OVRCameraRigì˜ TrackingSpaceë¥¼ ì°¾ì•„ì„œ ë³€í™˜
                Transform trackingSpace = FindObjectOfType<OVRCameraRig>()?.trackingSpace;
                if (trackingSpace)
                {
                    pos = trackingSpace.TransformPoint(pos);
                    rot = trackingSpace.rotation * rot;

                    Ray ray = new Ray(pos, rot * Vector3.forward);

                    if (Physics.Raycast(ray, out RaycastHit hit, 2f))
                    {
                        UnityEngine.Debug.Log($"[RadioClickable] VR Raycast hit: {hit.collider.gameObject.name}");

                        if (hit.collider.gameObject == gameObject)
                        {
                            UnityEngine.Debug.Log("[RadioClickable] Radio clicked via VR!");

                            // ğŸ”¥ í´ë¦­ í›„ ì¦‰ì‹œ ë¹„í™œì„±í™” (1íšŒë§Œ í´ë¦­)
                            _clickable = false;
                            UpdateVisuals();

                            OnRadioClicked?.Invoke();
                        }
                    }
                }
            }
        }
    }
}


/* =====================================================================
   FILE: RhythmConductor.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;
using UnityEngine.Events;

public class RhythmConductor : MonoBehaviour
{
    public enum RhythmState { Waiting, Guiding, Judging, Result, Cleanup }

    [Header("Data")]
    public RhythmTriggerListSO data;

    [Header("Refs")]
    public AudioSource bgmSource;
    public AudioSource sfxSource;
    public KimbapSpawner spawner;
    public DebugHUD hud;
    public PlateController plateController;

    [Header("Events")]
    public UnityEvent<Vector3, Vector3, float> OnSliceSuccess;
    public UnityEvent<Vector3, string> OnSliceFail;
    public UnityEvent<bool> OnRoundResult;
    public UnityEvent<Vector3> OnWrongCut;
    public UnityEvent OnTutorialSkipped;
    public UnityEvent OnTutorialCompleted;

    [Header("Settings")]
    public float resultDisplayDuration = 0.5f;

    [Header("Tutorial Mode")]
    public bool isTutorialMode = false;

    public RhythmState State { get; private set; } = RhythmState.Waiting;
    public int CurrentTriggerIndex { get; private set; } = -1;

    public float BgmTime { get; private set; }
    public int SliceCount { get; private set; }
    public int RequiredSliceCount { get; private set; }

    float _offsetSec;
    float _stateEndTime;
    bool _bgmStarted;
    bool _waitingForManualAdvance = false;

    void Awake()
    {
        if (!bgmSource) bgmSource = gameObject.AddComponent<AudioSource>();
        if (!sfxSource) sfxSource = gameObject.AddComponent<AudioSource>();
        _offsetSec = (data ? data.timingOffsetMs : 0f) / 1000f;

        if (hud) hud.Bind(this);
    }

    void Start()
    {
        // GameFlowManagerì—ì„œ í˜¸ì¶œí•˜ë„ë¡ ë³€ê²½
        // StartGame();
    }

    public void StartGame()
    {
        if (!data)
        {
            UnityEngine.Debug.LogError("[RhythmConductor] Missing data.");
            return;
        }

        // ğŸ”¥ BGM ì¬ìƒ (íŠœí† ë¦¬ì–¼/ë©”ì¸ ëª¨ë‘)
        if (data.bgm)
        {
            bgmSource.clip = data.bgm;
            bgmSource.loop = true; // íŠœí† ë¦¬ì–¼ì€ ë°˜ë³µ ì¬ìƒ
            bgmSource.Play();
            _bgmStarted = true;
            UnityEngine.Debug.Log($"[RhythmConductor] BGM started - Mode: {(isTutorialMode ? "Tutorial" : "Main")}");
        }
        else
        {
            UnityEngine.Debug.LogWarning("[RhythmConductor] No BGM assigned!");
            _bgmStarted = false;
        }

        State = RhythmState.Waiting;
        CurrentTriggerIndex = -1;
        SliceCount = 0;
        RequiredSliceCount = 0;
        _waitingForManualAdvance = false;

        if (spawner) spawner.EnsureKimbapExists();
        if (plateController) plateController.ResetToEmptyPlate();

        if (hud) hud.Log($"Game Started - Mode: {(isTutorialMode ? "Tutorial" : "Main")}");
    }

    void Update()
    {
        // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œì—ì„œëŠ” ì‹œê°„ ê¸°ë°˜ ì§„í–‰ ì™„ì „ ì°¨ë‹¨
        if (isTutorialMode)
        {
            // BGM ì‹œê°„ ì—…ë°ì´íŠ¸ë§Œ (ë””ë²„ê·¸ìš©)
            if (_bgmStarted && bgmSource.isPlaying)
            {
                BgmTime = bgmSource.time + _offsetSec;
            }

            // ìƒíƒœ ë¨¸ì‹ ë§Œ ì‘ë™ (íŠ¸ë¦¬ê±° ìë™ ì§„í–‰ X)
            TickStateMachine();
            return;
        }

        // ë©”ì¸ ê²Œì„ ëª¨ë“œ: ê¸°ì¡´ ë¡œì§
        if (!_bgmStarted) return;

        BgmTime = bgmSource.time + _offsetSec;

        AdvanceTriggerIfNeeded();
        TickStateMachine();
    }

    void AdvanceTriggerIfNeeded()
    {
        // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œì—ì„œëŠ” ì ˆëŒ€ í˜¸ì¶œë˜ì§€ ì•ŠìŒ
        if (isTutorialMode) return;

        if (data.triggers == null || data.triggers.Length == 0) return;

        int nextIndex = CurrentTriggerIndex + 1;
        if (nextIndex >= data.triggers.Length) return;

        if (BgmTime >= data.triggers[nextIndex].triggerTime)
        {
            EnterTrigger(nextIndex);
        }
    }

    void EnterTrigger(int idx)
    {
        CurrentTriggerIndex = idx;
        var t = data.triggers[idx];

        SliceCount = 0;
        RequiredSliceCount = Mathf.Max(1, t.requiredSliceCount);

        // ë¹ˆ ì ‘ì‹œë¡œ ì´ˆê¸°í™”
        if (plateController) plateController.ResetToEmptyPlate();

        if (spawner && spawner.CurrentKimbap)
        {
            spawner.CurrentKimbap.BeginTrigger(t);
        }

        State = RhythmState.Guiding;
        _stateEndTime = BgmTime + Mathf.Max(0.01f, t.guideDuration);

        if (t.guideBeatSound && sfxSource) sfxSource.PlayOneShot(t.guideBeatSound);

        if (hud) hud.Log($"Enter Trigger #{idx} (req={RequiredSliceCount}) - State: Guiding");
    }

    void TickStateMachine()
    {
        if (CurrentTriggerIndex < 0) return;
        var t = data.triggers[CurrentTriggerIndex];

        // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œ: ìˆ˜ë™ ì§„í–‰ ëŒ€ê¸° ì¤‘ì´ë©´ Result ì´í›„ Cleanupë§Œ ì°¨ë‹¨
        // Guiding -> Judging ì „í™˜ì€ ì •ìƒ ì‘ë™í•´ì•¼ í•¨!

        // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œ: Time.time ê¸°ì¤€ìœ¼ë¡œ ìƒíƒœ ì „í™˜
        float currentTime = isTutorialMode ? Time.time : BgmTime;

        if (State == RhythmState.Guiding && currentTime >= _stateEndTime)
        {
            State = RhythmState.Judging;
            _stateEndTime = currentTime + Mathf.Max(0.01f, t.judgeDuration);

            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.SetSliceable(true);

            if (hud) hud.Log("State -> Judging");
        }
        else if (State == RhythmState.Judging && currentTime >= _stateEndTime)
        {
            State = RhythmState.Result;

            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.SetSliceable(false);

            bool success = (SliceCount == RequiredSliceCount);
            if (spawner && spawner.CurrentKimbap)
                spawner.CurrentKimbap.OnTriggerResult(success);

            if (hud) hud.Log($"State -> Result (success={success})");

            OnRoundResult?.Invoke(success);

            // íŠœí† ë¦¬ì–¼ ëª¨ë“œ: ê²°ê³¼ í›„ ìˆ˜ë™ ì§„í–‰ ëŒ€ê¸°
            if (isTutorialMode)
            {
                _waitingForManualAdvance = true;
            }

            _stateEndTime = currentTime + resultDisplayDuration;
        }
        else if (State == RhythmState.Result && currentTime >= _stateEndTime)
        {
            // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œ: Result ì´í›„ ì¦‰ì‹œ Cleanup ì‹¤í–‰ (ê¹€ë°¥ êµì²´)
            State = RhythmState.Cleanup;
            if (hud) hud.Log("State -> Cleanup");

            if (spawner)
            {
                spawner.DestroyCurrentKimbap();
                spawner.EnsureKimbapExists();
                if (hud) hud.Log("New kimbap spawned after Result");
            }

            // ğŸ”¥ íŠœí† ë¦¬ì–¼ ëª¨ë“œ: Cleanup ì´í›„ ìˆ˜ë™ ì§„í–‰ ëŒ€ê¸°
            if (isTutorialMode)
            {
                State = RhythmState.Waiting;
                // _waitingForManualAdvanceëŠ” ì´ë¯¸ Resultì—ì„œ trueë¡œ ì„¤ì •ë¨
                return;
            }

            // ë©”ì¸ ê²Œì„: ë°”ë¡œ ë‹¤ìŒ Waitingìœ¼ë¡œ
            State = RhythmState.Waiting;
        }
    }

    public void RetryCurrentTrigger()
    {
        if (!isTutorialMode)
        {
            UnityEngine.Debug.LogWarning("[RhythmConductor] RetryCurrentTrigger called but not in tutorial mode!");
            return;
        }

        if (CurrentTriggerIndex < 0) return;

        UnityEngine.Debug.Log($"[RhythmConductor] Retrying trigger #{CurrentTriggerIndex}");

        _waitingForManualAdvance = false;

        // ğŸ”¥ ê¹€ë°¥ì€ ì´ë¯¸ Result -> Cleanupì—ì„œ êµì²´ë˜ì—ˆìœ¼ë¯€ë¡œ ì¬ìƒì„± ë¶ˆí•„ìš”
        // ëŒ€ì‹  í˜„ì¬ ê¹€ë°¥ì´ ì—†ìœ¼ë©´ ìƒì„±
        if (spawner && !spawner.CurrentKimbap)
        {
            spawner.EnsureKimbapExists();
        }

        // ğŸ”¥ Time.time ê¸°ì¤€ìœ¼ë¡œ ìƒíƒœ ì‹œê°„ ì„¤ì •
        var t = data.triggers[CurrentTriggerIndex];

        SliceCount = 0;
        RequiredSliceCount = Mathf.Max(1, t.requiredSliceCount);

        if (plateController) plateController.ResetToEmptyPlate();

        if (spawner && spawner.CurrentKimbap)
        {
            spawner.CurrentKimbap.BeginTrigger(t);
        }

        State = RhythmState.Guiding;
        _stateEndTime = Time.time + Mathf.Max(0.01f, t.guideDuration);

        if (t.guideBeatSound && sfxSource) sfxSource.PlayOneShot(t.guideBeatSound);

        if (hud) hud.Log($"Retry Trigger #{CurrentTriggerIndex} - State: Guiding");
    }

    public void AdvanceToNextTrigger()
    {
        if (!isTutorialMode)
        {
            UnityEngine.Debug.LogWarning("[RhythmConductor] AdvanceToNextTrigger called but not in tutorial mode!");
            return;
        }

        _waitingForManualAdvance = false;

        int nextIndex = CurrentTriggerIndex + 1;

        if (nextIndex >= data.triggers.Length)
        {
            UnityEngine.Debug.Log("[RhythmConductor] Tutorial completed - no more triggers");
            return;
        }

        UnityEngine.Debug.Log($"[RhythmConductor] Advancing to next trigger #{nextIndex}");

        // ğŸ”¥ ê¹€ë°¥ì€ ì´ë¯¸ Result -> Cleanupì—ì„œ êµì²´ë˜ì—ˆìœ¼ë¯€ë¡œ ì¬ìƒì„± ë¶ˆí•„ìš”
        // ëŒ€ì‹  í˜„ì¬ ê¹€ë°¥ì´ ì—†ìœ¼ë©´ ìƒì„±
        if (spawner && !spawner.CurrentKimbap)
        {
            spawner.EnsureKimbapExists();
        }

        CurrentTriggerIndex = nextIndex;
        var t = data.triggers[nextIndex];

        SliceCount = 0;
        RequiredSliceCount = Mathf.Max(1, t.requiredSliceCount);

        if (plateController) plateController.ResetToEmptyPlate();

        if (spawner && spawner.CurrentKimbap)
        {
            spawner.CurrentKimbap.BeginTrigger(t);
        }

        State = RhythmState.Guiding;
        _stateEndTime = Time.time + Mathf.Max(0.01f, t.guideDuration);

        if (t.guideBeatSound && sfxSource) sfxSource.PlayOneShot(t.guideBeatSound);

        if (hud) hud.Log($"Enter Trigger #{nextIndex} (req={RequiredSliceCount}) - State: Guiding");
    }

    public bool IsJudgingWindow()
    {
        return State == RhythmState.Judging && CurrentTriggerIndex >= 0;
    }

    public RhythmTriggerListSO.Trigger GetCurrentTrigger()
    {
        if (!data || data.triggers == null) return null;
        if (CurrentTriggerIndex < 0 || CurrentTriggerIndex >= data.triggers.Length) return null;
        return data.triggers[CurrentTriggerIndex];
    }

    public void RegisterValidSlice()
    {
        var t = GetCurrentTrigger();
        if (t == null) return;

        SliceCount++;
        if (hud) hud.Log($"ValidSlice! ({SliceCount}/{RequiredSliceCount})");
    }

    public void NotifySliceSuccess(Vector3 hitPos, Vector3 hitNormal, float knifeSpeed)
    {
        OnSliceSuccess?.Invoke(hitPos, hitNormal, knifeSpeed);
    }

    public void NotifySliceFail(Vector3 hitPos, string reason)
    {
        OnSliceFail?.Invoke(hitPos, reason);
    }

    public void NotifyWrongCut(Vector3 hitPos)
    {
        OnWrongCut?.Invoke(hitPos);
    }
}


/* =====================================================================
   FILE: RhythmTriggerListSO.cs
   ===================================================================== */

using UnityEngine;

[CreateAssetMenu(menuName = "KimbapRhythm/Rhythm Trigger List", fileName = "RhythmTriggerList")]
public class RhythmTriggerListSO : ScriptableObject
{
    public AudioClip bgm;
    public float timingOffsetMs = 0f;

    public Trigger[] triggers;

    [System.Serializable]
    public class Trigger
    {
        [Header("Time")]
        public float triggerTime;      // seconds on BGM timeline
        public float guideDuration = 0.4f;
        public float judgeDuration = 0.6f;
        public AudioClip guideBeatSound;

        [Header("Counts")]
        public int requiredSliceCount = 5;

        [Header("Judgement (simple)")]
        public float minKnifeSpeed = 1.0f; // m/s-ish (depends on scale)
        public float minContactMs = 10f;

        [Header("RightThin Slice (fixed)")]
        public float thinSliceThicknessNorm = 0.08f;
        public AnimationCurve thinThicknessCurve; // optional
        public float minThinThicknessWorld = 0.01f;
        public int maxActiveThinPieces = 6;

        [Header("Feedback")]
        [Range(0f, 1f)] public float hapticHitBase = 0.25f;
        [Range(0f, 1f)] public float hapticHitMax = 0.75f;
        public int hapticDurationMs = 25;
        public AudioClip impactSound;
        public AudioClip swishSound;
        public GameObject cutVfxPrefab;
        [Range(0f, 1f)] public float visualResistanceStrength = 0.6f;
        public int visualResistanceMs = 80;
    }
}



/* =====================================================================
   FILE: ThinPieceAutoCleanup.cs
   ===================================================================== */

using UnityEngine;

public class ThinPieceAutoCleanup : MonoBehaviour
{
    public KimbapController owner;
    public Vector3 flyDirection = Vector3.right;

    public float flySeconds = 0.2f;
    public float lifeSeconds = 1.2f;

    Vector3 _startPos;
    Quaternion _startRot;
    float _t;

    void Start()
    {
        _startPos = transform.position;
        _startRot = transform.rotation;

        // Remove heavy physics by default
        var rb = GetComponent<Rigidbody>();
        if (rb) Destroy(rb);

        // You can add a light collider if you want, but prototype ok without.
        // Disable colliders to avoid unexpected physics
        foreach (var c in GetComponentsInChildren<Collider>())
            c.enabled = false;
    }

    void Update()
    {
        _t += Time.deltaTime;

        // Fly animation
        if (_t <= flySeconds && flySeconds > 0f)
        {
            float u = _t / flySeconds;
            float ease = 1f - Mathf.Pow(1f - u, 3f);
            transform.position = _startPos + flyDirection.normalized * (0.06f * ease) + Vector3.up * (0.02f * ease);
            transform.rotation = _startRot * Quaternion.Euler(0f, 0f, 18f * ease);
        }

        if (_t >= lifeSeconds)
        {
            if (owner) owner.NotifyThinPieceDespawned();
            Destroy(gameObject);
        }
    }
}



/* =====================================================================
   FILE: TutorialController.cs
   ===================================================================== */

using System.Diagnostics;
using UnityEngine;

public class TutorialController : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public FeedbackSetSO feedbackSet;
    public RadioClickable radio;

    [Header("Tutorial Settings")]
    public RhythmTriggerListSO tutorialTriggerList;
    public int requiredSuccessCount = 3; // ê° ë‹¨ê³„ 3ë²ˆ ì„±ê³µ í•„ìš”

    [Header("UI Display (Optional)")]
    public UnityEngine.UI.Text progressText; // "Progress: 2/3" í‘œì‹œìš©

    int _currentStepIndex = 0;
    int _successCountThisStep = 0; // í˜„ì¬ ë‹¨ê³„ì—ì„œ ì„±ê³µí•œ íšŸìˆ˜
    bool _tutorialCompleted = false;
    bool _isProcessingResult = false; // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€

    float _lastSkipInput = -999f;

    void Update()
    {
        if (_tutorialCompleted) return;

        // A ë²„íŠ¼ìœ¼ë¡œ íŠœí† ë¦¬ì–¼ ìŠ¤í‚µ
        if (OVRInput.GetDown(OVRInput.Button.One))
        {
            if (Time.time - _lastSkipInput > (feedbackSet ? feedbackSet.skipInputCooldown : 0.5f))
            {
                _lastSkipInput = Time.time;
                SkipTutorial();
            }
        }

        // UI ì—…ë°ì´íŠ¸
        UpdateProgressUI();
    }

    void OnEnable()
    {
        if (conductor)
        {
            conductor.OnRoundResult.AddListener(HandleRoundResult);
        }
    }

    void OnDisable()
    {
        if (conductor)
        {
            conductor.OnRoundResult.RemoveListener(HandleRoundResult);
        }
    }

    public void StartTutorial()
    {
        if (!conductor || !tutorialTriggerList)
        {
            UnityEngine.Debug.LogError("[TutorialController] Missing conductor or tutorialTriggerList.");
            return;
        }

        _currentStepIndex = 0;
        _successCountThisStep = 0;
        _tutorialCompleted = false;
        _isProcessingResult = false;

        // íŠœí† ë¦¬ì–¼ ëª¨ë“œ í™œì„±í™”
        conductor.isTutorialMode = true;
        conductor.data = tutorialTriggerList;
        conductor.StartGame();

        UnityEngine.Debug.Log("[TutorialController] Tutorial started - Need 3 successes per step");

        // ì²« ë²ˆì§¸ íŠ¸ë¦¬ê±° ìˆ˜ë™ ì‹œì‘ (ì‹œê°„ ê¸°ë°˜ ì§„í–‰ ì°¨ë‹¨ë˜ë¯€ë¡œ)
        Invoke(nameof(StartFirstTrigger), 1.0f);
    }

    void StartFirstTrigger()
    {
        if (conductor && conductor.CurrentTriggerIndex < 0)
        {
            UnityEngine.Debug.Log("[TutorialController] Starting first trigger manually");
            conductor.AdvanceToNextTrigger();
        }
    }

    void HandleRoundResult(bool success)
    {
        if (_tutorialCompleted) return;
        if (_isProcessingResult) return; // ì¤‘ë³µ ë°©ì§€

        _isProcessingResult = true; // ì²˜ë¦¬ ì‹œì‘

        if (success)
        {
            _successCountThisStep++;
            UnityEngine.Debug.Log($"[TutorialController] Step {_currentStepIndex} SUCCESS! ({_successCountThisStep}/{requiredSuccessCount})");

            if (_successCountThisStep >= requiredSuccessCount)
            {
                UnityEngine.Debug.Log($"[TutorialController] Step {_currentStepIndex} COMPLETED!");

                _currentStepIndex++;
                _successCountThisStep = 0;

                // ëª¨ë“  ë‹¨ê³„ ì™„ë£Œ í™•ì¸
                if (_currentStepIndex >= tutorialTriggerList.triggers.Length)
                {
                    CompleteTutorial();
                    return;
                }

                // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™
                Invoke(nameof(MoveToNextStep), 1.0f);
            }
            else
            {
                // ê°™ì€ ë‹¨ê³„ ì¬ì‹œë„ (ì„±ê³µ ì¹´ìš´íŠ¸ ìœ ì§€)
                Invoke(nameof(RetryCurrentStep), 1.0f);
            }
        }
        else
        {
            // ì‹¤íŒ¨ ì‹œ ê°™ì€ ë‹¨ê³„ ì¬ì‹œë„ (ì„±ê³µ ì¹´ìš´íŠ¸ ìœ ì§€)
            UnityEngine.Debug.Log($"[TutorialController] Step {_currentStepIndex} FAILED (current: {_successCountThisStep}/{requiredSuccessCount})");
            Invoke(nameof(RetryCurrentStep), 1.0f);
        }
    }

    void MoveToNextStep()
    {
        if (conductor)
        {
            UnityEngine.Debug.Log($"[TutorialController] Moving to step {_currentStepIndex}...");
            conductor.AdvanceToNextTrigger();
        }

        _isProcessingResult = false; // ì²˜ë¦¬ ì™„ë£Œ
    }

    void RetryCurrentStep()
    {
        if (conductor)
        {
            UnityEngine.Debug.Log($"[TutorialController] Retrying step {_currentStepIndex}...");
            conductor.RetryCurrentTrigger();
        }

        _isProcessingResult = false; // ì²˜ë¦¬ ì™„ë£Œ
    }

    void SkipTutorial()
    {
        UnityEngine.Debug.Log("[TutorialController] Tutorial skipped by A button!");
        _tutorialCompleted = true;

        if (conductor)
        {
            conductor.isTutorialMode = false;

            // BGM ì •ì§€
            if (conductor.bgmSource)
            {
                conductor.bgmSource.Stop();
                UnityEngine.Debug.Log("[TutorialController] Tutorial BGM stopped");
            }
        }

        // ğŸ”¥ ë¼ë””ì˜¤ í™œì„±í™” + í´ë¦­ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
        if (radio)
        {
            radio.SetTutorialCompleted(true);
            radio.SetClickable(true); // í´ë¦­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
            UnityEngine.Debug.Log("[TutorialController] Radio unlocked and clickable after skip");
        }

        // ìŠ¤í‚µ ì´ë²¤íŠ¸ ë°œí–‰
        if (conductor.OnTutorialSkipped != null)
            conductor.OnTutorialSkipped.Invoke();
    }

    void CompleteTutorial()
    {
        UnityEngine.Debug.Log("[TutorialController] Tutorial completed! All steps cleared.");
        _tutorialCompleted = true;

        if (conductor)
        {
            conductor.isTutorialMode = false;

            // BGM ì •ì§€
            if (conductor.bgmSource)
            {
                conductor.bgmSource.Stop();
                UnityEngine.Debug.Log("[TutorialController] Tutorial BGM stopped");
            }
        }

        // ğŸ”¥ ë¼ë””ì˜¤ í™œì„±í™” + í´ë¦­ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
        if (radio)
        {
            radio.SetTutorialCompleted(true);
            radio.SetClickable(true); // í´ë¦­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
            UnityEngine.Debug.Log("[TutorialController] Radio unlocked and clickable after completion");
        }

        // ì™„ë£Œ ì´ë²¤íŠ¸ ë°œí–‰
        if (conductor.OnTutorialCompleted != null)
            conductor.OnTutorialCompleted.Invoke();
    }

    void UpdateProgressUI()
    {
        if (!progressText || _tutorialCompleted) return;

        progressText.text = $"Step {_currentStepIndex + 1}/{tutorialTriggerList.triggers.Length}\nProgress: {_successCountThisStep}/{requiredSuccessCount}";
    }
}


/* =====================================================================
   FILE: TutorialUIController.cs
   ===================================================================== */

using UnityEngine;
using UnityEngine.UI;
using static System.Net.Mime.MediaTypeNames;

public class TutorialUIController : MonoBehaviour
{
    [Header("Refs")]
    public RhythmConductor conductor;
    public Canvas tutorialCanvas; // World Space Canvas

    [Header("UI Elements")]
    public UnityEngine.UI.Text instructionText;      // "ê°€ì´ë“œ ìŒì´ ë“¤ë¦¬ë©´ 3ì´ˆ ì•ˆì— 3ë²ˆ ìë¥´ì„¸ìš”!"
    public UnityEngine.UI.Text progressText;         // "ì§„í–‰: 2/3"
    public UnityEngine.UI.Text stateText;            // "ì¤€ë¹„..." / "ìë¥´ì„¸ìš”!" / "ì„±ê³µ!" / "ì‹¤íŒ¨!"
    public UnityEngine.UI.Image progressBarFill;     // ì‹œê°„ ë°” (ì„ íƒì‚¬í•­)

    [Header("Colors")]
    public Color guidingColor = Color.yellow;
    public Color judgingColor = Color.green;
    public Color successColor = Color.cyan;
    public Color failColor = Color.red;

    [Header("Animation")]
    public float fadeInDuration = 0.3f;
    public float fadeOutDuration = 0.3f;

    CanvasGroup _canvasGroup;
    float _fadeTimer;
    bool _isFading;
    bool _targetVisible;

    void Awake()
    {
        // CanvasGroup ì¶”ê°€ (í˜ì´ë“œ ì¸/ì•„ì›ƒìš©)
        if (!_canvasGroup)
        {
            _canvasGroup = tutorialCanvas.gameObject.AddComponent<CanvasGroup>();
        }

        // ì´ˆê¸° ìƒíƒœ: ìˆ¨ê¹€
        _canvasGroup.alpha = 0f;
        tutorialCanvas.gameObject.SetActive(false);
    }

    void OnEnable()
    {
        if (conductor)
        {
            conductor.OnRoundResult.AddListener(HandleRoundResult);
        }
    }

    void OnDisable()
    {
        if (conductor)
        {
            conductor.OnRoundResult.RemoveListener(HandleRoundResult);
        }
    }

    void Update()
    {
        if (!conductor || !conductor.isTutorialMode)
        {
            // íŠœí† ë¦¬ì–¼ ëª¨ë“œ ì•„ë‹ˆë©´ ìˆ¨ê¹€
            if (tutorialCanvas.gameObject.activeSelf)
            {
                tutorialCanvas.gameObject.SetActive(false);
            }
            return;
        }

        // í˜ì´ë“œ ì²˜ë¦¬
        HandleFade();

        // ìƒíƒœì— ë”°ë¼ UI ì—…ë°ì´íŠ¸
        UpdateUI();

        // ì‹œê°„ ë°” ì—…ë°ì´íŠ¸ (ì„ íƒì‚¬í•­)
        UpdateProgressBar();
    }

    void HandleFade()
    {
        if (!_isFading) return;

        _fadeTimer += Time.deltaTime;

        if (_targetVisible)
        {
            // Fade In
            float t = Mathf.Clamp01(_fadeTimer / fadeInDuration);
            _canvasGroup.alpha = t;

            if (t >= 1f)
            {
                _isFading = false;
            }
        }
        else
        {
            // Fade Out
            float t = Mathf.Clamp01(_fadeTimer / fadeOutDuration);
            _canvasGroup.alpha = 1f - t;

            if (t >= 1f)
            {
                _isFading = false;
                tutorialCanvas.gameObject.SetActive(false);
            }
        }
    }

    void UpdateUI()
    {
        if (conductor.CurrentTriggerIndex < 0) return;

        var trigger = conductor.GetCurrentTrigger();
        if (trigger == null) return;

        // ì§„í–‰ ìƒí™© í…ìŠ¤íŠ¸
        if (progressText)
        {
            progressText.text = $"ì§„í–‰: {conductor.SliceCount} / {conductor.RequiredSliceCount}";
        }

        // ìƒíƒœë³„ í…ìŠ¤íŠ¸ & ìƒ‰ìƒ
        switch (conductor.State)
        {
            case RhythmConductor.RhythmState.Guiding:
                UpdateGuidingState(trigger);
                break;

            case RhythmConductor.RhythmState.Judging:
                UpdateJudgingState(trigger);
                break;

            case RhythmConductor.RhythmState.Result:
                // ResultëŠ” HandleRoundResultì—ì„œ ì²˜ë¦¬
                break;

            case RhythmConductor.RhythmState.Waiting:
                // Waiting ìƒíƒœì—ì„œëŠ” UI ìˆ¨ê¹€
                if (_targetVisible)
                {
                    FadeOut();
                }
                break;
        }
    }

    void UpdateGuidingState(RhythmTriggerListSO.Trigger trigger)
    {
        if (!_targetVisible)
        {
            FadeIn();
        }

        // ê°€ì´ë“œ ìŒì´ ë“¤ë¦´ ë•Œ
        if (instructionText)
        {
            float judgeDuration = trigger.judgeDuration;
            instructionText.text = $"ê°€ì´ë“œ ìŒì´ ë“¤ë¦¬ë©´\n{judgeDuration:F1}ì´ˆ ì•ˆì— {trigger.requiredSliceCount}ë²ˆ ìë¥´ì„¸ìš”!";
            instructionText.color = guidingColor;
        }

        if (stateText)
        {
            stateText.text = "ì¤€ë¹„...";
            stateText.color = guidingColor;
        }
    }

    void UpdateJudgingState(RhythmTriggerListSO.Trigger trigger)
    {
        if (!_targetVisible)
        {
            FadeIn();
        }

        // ìë¥´ëŠ” ì¤‘
        if (instructionText)
        {
            instructionText.text = $"ë¹ ë¥´ê²Œ ìë¥´ì„¸ìš”!\në‚¨ì€ íšŸìˆ˜: {conductor.RequiredSliceCount - conductor.SliceCount}";
            instructionText.color = judgingColor;
        }

        if (stateText)
        {
            stateText.text = "ìë¥´ì„¸ìš”!";
            stateText.color = judgingColor;
        }
    }

    void HandleRoundResult(bool success)
    {
        if (!conductor.isTutorialMode) return;

        // ê²°ê³¼ í‘œì‹œ
        if (instructionText)
        {
            if (success)
            {
                instructionText.text = "ì„±ê³µ!";
                instructionText.color = successColor;
            }
            else
            {
                instructionText.text = "ì‹¤íŒ¨... ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”!";
                instructionText.color = failColor;
            }
        }

        if (stateText)
        {
            if (success)
            {
                stateText.text = "ì„±ê³µ!";
                stateText.color = successColor;
            }
            else
            {
                stateText.text = "ì‹¤íŒ¨!";
                stateText.color = failColor;
            }
        }

        // ì ì‹œ í›„ í˜ì´ë“œ ì•„ì›ƒ
        Invoke(nameof(FadeOut), 1.5f);
    }

    void UpdateProgressBar()
    {
        if (!progressBarFill) return;
        if (conductor.State != RhythmConductor.RhythmState.Judging) return;

        var trigger = conductor.GetCurrentTrigger();
        if (trigger == null) return;

        // ë‚¨ì€ ì‹œê°„ ë¹„ìœ¨
        float elapsed = Time.time - (conductor.BgmTime - trigger.judgeDuration);
        float progress = Mathf.Clamp01(elapsed / trigger.judgeDuration);

        progressBarFill.fillAmount = 1f - progress;
    }

    public void FadeIn()
    {
        if (!tutorialCanvas.gameObject.activeSelf)
        {
            tutorialCanvas.gameObject.SetActive(true);
        }

        _targetVisible = true;
        _isFading = true;
        _fadeTimer = 0f;
    }

    public void FadeOut()
    {
        _targetVisible = false;
        _isFading = true;
        _fadeTimer = 0f;
    }

    // TutorialControllerì—ì„œ í˜¸ì¶œ
    public void ShowStepInstruction(int stepIndex, int requiredCount, float judgeDuration)
    {
        FadeIn();

        if (instructionText)
        {
            instructionText.text = $"ë‹¨ê³„ {stepIndex + 1}\nê°€ì´ë“œ ìŒì´ ë“¤ë¦¬ë©´ {judgeDuration:F1}ì´ˆ ì•ˆì— {requiredCount}ë²ˆ ìë¥´ì„¸ìš”!";
            instructionText.color = guidingColor;
        }

        if (stateText)
        {
            stateText.text = "ì¤€ë¹„...";
            stateText.color = guidingColor;
        }
    }

    public void Hide()
    {
        FadeOut();
    }
}


/* =====================================================================
   FILE: XRHaptics.cs
   ===================================================================== */

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;

public static class XRHaptics
{
    public static void SendHaptic(bool rightHand, float amplitude01, float durationSeconds)
    {
        amplitude01 = Mathf.Clamp01(amplitude01);
        durationSeconds = Mathf.Clamp(durationSeconds, 0.01f, 0.25f);

        var desired = rightHand ? InputDeviceCharacteristics.Right : InputDeviceCharacteristics.Left;
        desired |= InputDeviceCharacteristics.Controller;

        var devices = new List<InputDevice>();
        InputDevices.GetDevicesWithCharacteristics(desired, devices);

        foreach (var d in devices)
        {
            if (!d.isValid) continue;
            if (d.TryGetHapticCapabilities(out var caps) && caps.supportsImpulse)
            {
                // channel 0 is common
                d.SendHapticImpulse(0u, amplitude01, durationSeconds);
                return;
            }
        }
        // Simulator/Editor may not support haptics; that's okay.
    }
}


